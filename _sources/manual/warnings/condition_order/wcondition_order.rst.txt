[-Wcondition-order]
-------------------

Some older re2c programs that use ``-c --conditions`` option rely on a fixed
condition order instead of using ``/*!types:re2c*/`` directive or the
``-t --type-header`` option. This is incorrect and dangerous, as demonstrated by
the following example :download:`[fixorder.re]
</manual/warnings/condition_order/fixorder.re.txt>`. In this example
the lexer has two conditions: ``a`` and ``b``. It starts in condition ``a``,
which expects a sequence of letters ``a`` followed by a comma. The comma causes
transition to condition ``b``, which expects a sequence of letters ``b``
followed by an exclamation mark. Anything other input is an error. Nothing
special, except that condition numbers are hardcoded manually (the mapping of
conditions to numbers is toggled by ``REVERSED_CONDITION_ORDER`` define).

.. literalinclude:: /manual/warnings/condition_order/fixorder.re.txt
    :language: cpp

Let's compile and run it.
Everything works fine: we get ``aaaa,bbb!`` in both cases.

.. code-block:: none

    $ re2c -c -o fixorder.c -Wcondition-order fixorder.re
    $
    $ c++ -o fixorder fixorder.c && ./fixorder
    aaaa,bbb!
    $
    $ c++ -o fixorder fixorder.c -DREVERSED_CONDITION_ORDER && ./fixorder
    aaaa,bbb!

However, if we use the ``-s`` re2c option, the lexer becomes sensitive to condition order:

.. code-block:: none

    $ re2c -cs -o fixorder.c -Wcondition-order fixorder.re
    fixorder.re:31:6: warning: looks like you use hardcoded numbers instead of autogenerated condition names:
    better add '/*!types:re2c*/' directive or '-t, --type-header' option and don't rely on fixed condition order. [-Wcondition-order]
    $
    $ c++ -o fixorder fixorder.c && ./fixorder
    aaaa,bbb!
    $
    $ c++ -o fixorder fixorder.c -DREVERSED_CONDITION_ORDER && ./fixorder
    error

And we get a warning from re2c. The same behavior remains if we use ``-g`` or
``-b`` option. Why is that? A look at the generated code explains everything.
By default the initial dispatch on conditions is a ``switch`` statement:

.. code-block:: cpp

	switch (c) {
	case yyca: goto yyc_a;
	case yycb: goto yyc_b;
	}

Dispatch uses explicit condition names and works no matter what numbers are assigned to them.
However, with the ``-s`` option, re2c generates an ``if`` statement instead of a ``switch``:

.. code-block:: cpp

	if (c < 1) {
		goto yyc_a;
	} else {
		goto yyc_b;
	}

And with the ``-g`` option, it uses a jump table (computed ``goto``):

.. code-block:: cpp

	static void *yyctable[2] = {
		&&yyc_a,
		&&yyc_b,
	};
	goto *yyctable[c];

The last two cases are sensitive to condition order. The fix is easy: as the
warning suggests, use the ``/*!types:re2c*/`` directive or the
``-t, --type-header`` option.
