
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>User manual (re2c) &#8212; re2c 2.1.1 documentation</title>
    <link rel="stylesheet" href="../_static/theme-re2c.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
    
 
  </head><body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c
</div>

<h3><a href="../index.html">Home</a></h3>
<div class="re2c-toc-global">
    <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">User manual (C)</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_go.html">User manual (Go)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/install.html">Build instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../benchmarks/benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases/release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases/changelog/changelog.html">Changelog</a></li>
</ul>

</div>
    <h3>User manual (re2c)</h3>
    <div class="re2c-toc-local">
        <ul>
<li><a class="reference internal" href="#">User manual (re2c)</a><ul>
<li><a class="reference internal" href="#command-line-interface">Command-line interface</a><ul>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#warnings">Warnings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#program-interface">Program interface</a><ul>
<li><a class="reference internal" href="#api-primitives">API primitives</a></li>
<li><a class="reference internal" href="#directives">Directives</a></li>
<li><a class="reference internal" href="#configurations">Configurations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#regular-expressions">Regular expressions</a></li>
<li><a class="reference internal" href="#handling-the-end-of-input">Handling the end of input</a><ul>
<li><a class="reference internal" href="#sentinel-character">Sentinel character</a></li>
<li><a class="reference internal" href="#sentinel-character-with-bounds-checks">Sentinel character with bounds checks</a></li>
<li><a class="reference internal" href="#bounds-checks-with-padding">Bounds checks with padding</a></li>
<li><a class="reference internal" href="#custom-methods-with-generic-api">Custom methods with generic API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#buffer-refilling">Buffer refilling</a><ul>
<li><a class="reference internal" href="#yyfill-with-sentinel-character">YYFILL with sentinel character</a></li>
<li><a class="reference internal" href="#yyfill-with-padding">YYFILL with padding</a></li>
</ul>
</li>
<li><a class="reference internal" href="#include-files">Include files</a></li>
<li><a class="reference internal" href="#header-files">Header files</a></li>
<li><a class="reference internal" href="#submatch-extraction">Submatch extraction</a></li>
<li><a class="reference internal" href="#storable-state">Storable state</a></li>
<li><a class="reference internal" href="#reusable-blocks">Reusable blocks</a></li>
<li><a class="reference internal" href="#encoding-support">Encoding support</a></li>
<li><a class="reference internal" href="#start-conditions">Start conditions</a></li>
<li><a class="reference internal" href="#skeleton-programs">Skeleton programs</a></li>
<li><a class="reference internal" href="#visualization-and-debug">Visualization and debug</a></li>
<li><a class="reference internal" href="#more-examples">More examples</a></li>
</ul>
</li>
</ul>

    </div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="user-manual-re2c">
<h1>User manual (re2c)<a class="headerlink" href="#user-manual-re2c" title="Permalink to this headline">Â¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p style="color:gray";><i></i></p><p>A re2c program consists of normal code intermixed with re2c blocks and <a class="reference internal" href="#directives">directives</a>.
Each re2c block may contain definitions, configurations and rules.
Definitions are of the form <code class="docutils literal notranslate"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">regexp;</span></code>  where <code class="docutils literal notranslate"><span class="pre">name</span></code> is an identifier that
consists of letters, digits and underscores, and <code class="docutils literal notranslate"><span class="pre">regexp</span></code> is a regular expression.
<a class="reference internal" href="#regular-expressions">Regular expressions</a> may contain other definitions, but recursion is not allowed and each name should be defined before used.
<a class="reference internal" href="#configurations">Configurations</a> are of the form <code class="docutils literal notranslate"><span class="pre">re2c:config</span> <span class="pre">=</span> <span class="pre">value;</span></code> where <code class="docutils literal notranslate"><span class="pre">config</span></code> is the configuration descriptor
and <code class="docutils literal notranslate"><span class="pre">value</span></code> can be a number, a string or a special word.
Rules consist of a regular expression followed by a semantic action
(a block of code enclosed in curly braces <code class="docutils literal notranslate"><span class="pre">{</span></code> and <code class="docutils literal notranslate"><span class="pre">}</span></code>,
or a raw one line of code preceded with <code class="docutils literal notranslate"><span class="pre">:=</span></code> and ended with a newline that is not followed by a whitespace).
If the input matches the regular expression, the associated semantic action is executed.
If multiple rules match, the longest match takes precedence.
If multiple rules match the same string, the earlier rule takes precedence.
There are two special rules: default rule <code class="docutils literal notranslate"><span class="pre">*</span></code> and EOF rule <code class="docutils literal notranslate"><span class="pre">$</span></code>.
Default rule should always be defined, it has the lowest priority regardless of its place and matches any code unit (not necessarily a valid character, see <a class="reference internal" href="#encoding-support">encoding support</a>).
EOF rule matches the end of input, it should be defined if the corresponding method for <a class="reference internal" href="#handling-the-end-of-input">handling the end of input</a> is used.
If <a class="reference internal" href="#start-conditions">start conditions</a> are used, rules have more complex syntax.
All rules of a single block are compiled into a deterministic finite-state automaton (DFA) and encoded in the form of a program in the target language.
The generated code interfaces with the outer program by the means of a few user-defined primitives (see the <a class="reference internal" href="#program-interface">program interface</a> section).
<a class="reference internal" href="#reusable-blocks">Reusable blocks</a> allow sharing rules, definitions and configurations between different blocks.</p>
<p>Here is an example program that shows various aspects of re2c syntax:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -i</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="c1">                 //</span><span class="cp"></span>
                                    <span class="c1">// C/C++ code</span>
<span class="kt">int</span> <span class="nf">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>       <span class="c1">//</span>
<span class="p">{</span>
    <span class="cm">/*!re2c                         // start of re2c block</span>
<span class="cm">    re2c:define:YYCTYPE = char;     // configuration</span>
<span class="cm">    re2c:yyfill:enable = 0;         // configuration</span>
<span class="cm">    re2c:flags:case-ranges = 1;     // configuration</span>
<span class="cm">                                    //</span>
<span class="cm">    ident = [a-zA-Z_][a-zA-Z_0-9]*; // named definition</span>
<span class="cm">                                    //</span>
<span class="cm">    ident { return 0; }             // normal rule</span>
<span class="cm">    *     { return 1; }             // default rule</span>
<span class="cm">    */</span>
<span class="p">}</span>                                   <span class="c1">//</span>
                                    <span class="c1">//</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>                          <span class="c1">//</span>
<span class="p">{</span>                                   <span class="c1">// C/C++ code</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;_Zer0&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>      <span class="c1">//</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>                       <span class="c1">//</span>
<span class="p">}</span>                                   <span class="c1">//</span>
</pre></div>
</div>
<p>This is the generated output:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Generated by re2c */</span>
<span class="c1">// re2c $INPUT -o $OUTPUT -i</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="c1">                 //</span><span class="cp"></span>
                                    <span class="c1">// C/C++ code</span>
<span class="kt">int</span> <span class="nf">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>       <span class="c1">//</span>
<span class="p">{</span>
    
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">yych</span><span class="p">;</span>
	<span class="n">yych</span> <span class="o">=</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">yych</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;A&#39;</span> <span class="p">...</span> <span class="sc">&#39;Z&#39;</span><span class="o">:</span>
	<span class="k">case</span> <span class="sc">&#39;_&#39;</span><span class="o">:</span>
	<span class="k">case</span> <span class="sc">&#39;a&#39;</span> <span class="p">...</span> <span class="sc">&#39;z&#39;</span><span class="o">:</span> <span class="k">goto</span> <span class="n">yy4</span><span class="p">;</span>
	<span class="k">default</span><span class="o">:</span> <span class="k">goto</span> <span class="n">yy2</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">yy2</span><span class="p">:</span>
	<span class="o">++</span><span class="n">YYCURSOR</span><span class="p">;</span>
	<span class="p">{</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="nl">yy4</span><span class="p">:</span>
	<span class="n">yych</span> <span class="o">=</span> <span class="o">*++</span><span class="n">YYCURSOR</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">yych</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;0&#39;</span> <span class="p">...</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span>
	<span class="k">case</span> <span class="sc">&#39;A&#39;</span> <span class="p">...</span> <span class="sc">&#39;Z&#39;</span><span class="o">:</span>
	<span class="k">case</span> <span class="sc">&#39;_&#39;</span><span class="o">:</span>
	<span class="k">case</span> <span class="sc">&#39;a&#39;</span> <span class="p">...</span> <span class="sc">&#39;z&#39;</span><span class="o">:</span> <span class="k">goto</span> <span class="n">yy4</span><span class="p">;</span>
	<span class="k">default</span><span class="o">:</span> <span class="k">goto</span> <span class="n">yy6</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">yy6</span><span class="p">:</span>
	<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>                                   <span class="c1">//</span>
                                    <span class="c1">//</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>                          <span class="c1">//</span>
<span class="p">{</span>                                   <span class="c1">// C/C++ code</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;_Zer0&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>      <span class="c1">//</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>                       <span class="c1">//</span>
<span class="p">}</span>                                   <span class="c1">//</span>
</pre></div>
</div>
<div class="section" id="command-line-interface">
<h2>Command-line interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">Â¶</a></h2>
<p>Command-line interface consists of options and warnings.
Some of the options have corresponding <a class="reference internal" href="#configurations">configurations</a>,
others are global and cannot be changed after re2c starts reading the input file.
Debug options generally require building re2c in debug configuration.
Internal options are useful for experimenting with the algorithms used in re2c.
Each warning can be enabled, disabled and turned into an error.</p>
<div class="section" id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">Â¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-?</span> <span class="pre">-h</span> <span class="pre">--help</span></code></dt><dd><p>Show help message.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">--single-pass</span></code></dt><dd><p>Deprecated. Does nothing (single pass is the default now).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-8</span> <span class="pre">--utf-8</span></code></dt><dd><p>Generate a lexer that reads input in UTF-8 encoding.
re2c assumes that character range is 0 â 0x10FFFF and character size is
1 byte.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-b</span> <span class="pre">--bit-vectors</span></code></dt><dd><p>Optimize conditional jumps using bit masks. Implies <code class="docutils literal notranslate"><span class="pre">-s</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">--conditions</span> <span class="pre">--start-conditions</span></code></dt><dd><p>Enable support of Flex-like âconditionsâ: multiple interrelated lexers
within one block. Option <code class="docutils literal notranslate"><span class="pre">--start-conditions</span></code> is a legacy alias; use
<code class="docutils literal notranslate"><span class="pre">--conditions</span></code> instead.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-insensitive</span></code></dt><dd><p>Treat single-quoted and double-quoted strings as case-insensitive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-inverted</span></code></dt><dd><p>Invert the meaning of single-quoted and double-quoted strings:
treat single-quoted strings as case-sensitive and double-quoted strings
as case-insensitive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--case-ranges</span></code></dt><dd><p>Collapse consecutive cases in a switch statements into a range of the form
<code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">low</span> <span class="pre">...</span> <span class="pre">high:</span></code>. This syntax is an extension of the C/C++ language,
supported by compilers like GCC, Clang and Tcc. The main advantage over
using single cases is smaller generated C code and faster generation time,
although for some compilers like Tcc it also results in smaller binary size.
This option doesnât work for the Go backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--depfile</span> <span class="pre">FILE</span></code></dt><dd><p>Write dependency information to <code class="docutils literal notranslate"><span class="pre">FILE</span></code> in the form of a Makefile rule
<code class="docutils literal notranslate"><span class="pre">&lt;output-file&gt;</span> <span class="pre">:</span> <span class="pre">&lt;input-file&gt;</span> <span class="pre">[include-file</span> <span class="pre">...]</span></code>. This allows to track
build dependencies in the presence of <code class="docutils literal notranslate"><span class="pre">/*!include:re2c*/</span></code> directives, so
that updating include files triggers regeneration of the output file.
This option requires that <code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">--output</span></code> option is specified.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-e</span> <span class="pre">--ecb</span></code></dt><dd><p>Generate a lexer that reads input in EBCDIC encoding.
re2c assumes that character range is 0 â 0xFF an character size is 1 byte.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--empty-class</span> <span class="pre">&lt;match-empty</span> <span class="pre">|</span> <span class="pre">match-none</span> <span class="pre">|</span> <span class="pre">error&gt;</span></code></dt><dd><p>Define the way re2c treats empty character classes. With <code class="docutils literal notranslate"><span class="pre">match-empty</span></code>
(the default) empty class matches empty input (which is illogical, but
backwards-compatible). With <code class="docutils literal notranslate"><span class="pre">match-none</span></code> empty class always fails to match.
With <code class="docutils literal notranslate"><span class="pre">error</span></code> empty class raises a compilation error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--encoding-policy</span> <span class="pre">&lt;fail</span> <span class="pre">|</span> <span class="pre">substitute</span> <span class="pre">|</span> <span class="pre">ignore&gt;</span></code></dt><dd><p>Define the way re2c treats Unicode surrogates.
With <code class="docutils literal notranslate"><span class="pre">fail</span></code> re2c aborts with an error when a surrogate is encountered.
With <code class="docutils literal notranslate"><span class="pre">substitute</span></code> re2c silently replaces surrogates with the error code
point 0xFFFD. With <code class="docutils literal notranslate"><span class="pre">ignore</span></code> (the default) re2c treats surrogates as
normal code points. The Unicode standard says that standalone surrogates
are invalid, but real-world libraries and programs behave in different ways.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">--storable-state</span></code></dt><dd><p>Generate a lexer which can store its inner state.
This is useful in push-model lexers which are stopped by an outer program
when there is not enough input, and then resumed when more input becomes
available. In this mode users should additionally define <code class="docutils literal notranslate"><span class="pre">YYGETSTATE()</span></code>
and <code class="docutils literal notranslate"><span class="pre">YYSETSTATE(state)</span></code> macros and variables <code class="docutils literal notranslate"><span class="pre">yych</span></code>, <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code>
and <code class="docutils literal notranslate"><span class="pre">state</span></code> as part of the lexer state.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-F</span> <span class="pre">--flex-syntax</span></code></dt><dd><p>Partial support for Flex syntax: in this mode named definitions donât need
the equal sign and the terminating semicolon, and when used they must be
surrounded by curly braces. Names without curly braces are treated as
double-quoted strings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-g</span> <span class="pre">--computed-gotos</span></code></dt><dd><p>Optimize conditional jumps using non-standard âcomputed gotoâ extension
(which must be supported by the compiler). re2c generates jump tables
only in complex cases with a lot of conditional branches. Complexity
threshold can be configured with <code class="docutils literal notranslate"><span class="pre">cgoto:threshold</span></code> configuration. This
option implies <code class="docutils literal notranslate"><span class="pre">-b</span></code>. This option doesnât work for the Go backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-I</span> <span class="pre">PATH</span></code></dt><dd><p>Add <code class="docutils literal notranslate"><span class="pre">PATH</span></code> to the list of locations which are used when searching for
include files. This option is useful in combination with
<code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code> directive. Re2c looks for <code class="docutils literal notranslate"><span class="pre">FILE</span></code> in the
directory of including file and in the list of include paths specified by
<code class="docutils literal notranslate"><span class="pre">-I</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-i</span> <span class="pre">--no-debug-info</span></code></dt><dd><p>Do not output <code class="docutils literal notranslate"><span class="pre">#line</span></code> information. This is useful when the generated code
is tracked by some version control system or IDE.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--input</span> <span class="pre">&lt;default</span> <span class="pre">|</span> <span class="pre">custom&gt;</span></code></dt><dd><p>Specify the API used by the generated code to interface with used-defined
code. Option <code class="docutils literal notranslate"><span class="pre">default</span></code> is the C API based on pointer arithmetic (it is
the default for the C backend). Option <code class="docutils literal notranslate"><span class="pre">custom</span></code> is the generic API (it is
the default for the Go backend).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--input-encoding</span> <span class="pre">&lt;ascii</span> <span class="pre">|</span> <span class="pre">utf8&gt;</span></code></dt><dd><p>Specify the way re2c parses regular expressions.
With <code class="docutils literal notranslate"><span class="pre">ascii</span></code> (the default) re2c handles input as ASCII-encoded: any
sequence of code units is a sequence of standalone 1-byte characters.
With <code class="docutils literal notranslate"><span class="pre">utf8</span></code> re2c handles input as UTF8-encoded and recognizes multibyte
characters.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--lang</span> <span class="pre">&lt;c</span> <span class="pre">|</span> <span class="pre">go&gt;</span></code></dt><dd><p>Specify the output language. Supported languages are C and Go (the default
is C).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--location-format</span> <span class="pre">&lt;gnu</span> <span class="pre">|</span> <span class="pre">msvc&gt;</span></code></dt><dd><p>Specify location format in messages.
With <code class="docutils literal notranslate"><span class="pre">gnu</span></code> locations are printed as âfilename:line:column: â¦â.
With <code class="docutils literal notranslate"><span class="pre">msvc</span></code> locations are printed as âfilename(line,column) â¦â.
Default is <code class="docutils literal notranslate"><span class="pre">gnu</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-generation-date</span></code></dt><dd><p>Suppress date output in the generated file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-version</span></code></dt><dd><p>Suppress version output in the generated file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-o</span> <span class="pre">OUTPUT</span> <span class="pre">--output=OUTPUT</span></code></dt><dd><p>Specify the <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code> file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code></dt><dd><p>Enable submatch extraction with POSIX-style capturing groups.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code></dt><dd><p>Allows reuse of re2c rules with <code class="docutils literal notranslate"><span class="pre">/*!rules:re2c</span> <span class="pre">*/</span></code> and <code class="docutils literal notranslate"><span class="pre">/*!use:re2c</span> <span class="pre">*/</span></code>
blocks. Exactly one rules-block must be present. The rules are saved and
used by every use-block that follows, which may add its own rules and
configurations.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-S</span> <span class="pre">--skeleton</span></code></dt><dd><p>Ignore user-defined interface code and generate a self-contained âskeletonâ
program. Additionally, generate input files with strings derived from the
regular grammar and compressed match results that are used to verify
âskeletonâ behavior on all inputs. This option is useful for finding bugs
in optimizations and code generation. This option doesnât work for the Go
backend.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-s</span> <span class="pre">--nested-ifs</span></code></dt><dd><p>Use nested <code class="docutils literal notranslate"><span class="pre">if</span></code> statements instead of <code class="docutils literal notranslate"><span class="pre">switch</span></code> statements in conditional
jumps. This usually results in more efficient code with non-optimizing
compilers.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-T</span> <span class="pre">--tags</span></code></dt><dd><p>Enable submatch extraction with tags.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">HEADER</span> <span class="pre">--type-header=HEADER</span></code></dt><dd><p>Generate a <code class="docutils literal notranslate"><span class="pre">HEADER</span></code> file that contains enum with condition names.
Requires <code class="docutils literal notranslate"><span class="pre">-c</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-u</span> <span class="pre">--unicode</span></code></dt><dd><p>Generate a lexer that reads UTF32-encoded input. Re2c assumes that character
range is 0 â 0x10FFFF and character size is 4 bytes. This option implies
<code class="docutils literal notranslate"><span class="pre">-s</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-V</span> <span class="pre">--vernum</span></code></dt><dd><p>Show version information in <code class="docutils literal notranslate"><span class="pre">MMmmpp</span></code> format (major, minor, patch).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--verbose</span></code></dt><dd><p>Output a short message in case of success.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-v</span> <span class="pre">--version</span></code></dt><dd><p>Show version information.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-w</span> <span class="pre">--wide-chars</span></code></dt><dd><p>Generate a lexer that reads UCS2-encoded input. Re2c assumes that character
range is 0 â 0xFFFF and character size is 2 bytes. This option implies
<code class="docutils literal notranslate"><span class="pre">-s</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">--utf-16</span></code></dt><dd><p>Generate a lexer that reads UTF16-encoded input. Re2c assumes that character
range is 0 â 0x10FFFF and character size is 2 bytes. This option implies
<code class="docutils literal notranslate"><span class="pre">-s</span></code>.</p>
</dd>
</dl>
<p>Debug options:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-D</span> <span class="pre">--emit-dot</span></code></dt><dd><p>Instead of normal output generate lexer graph in .dot format.
The output can be converted to an image with the help of Graphviz
(e.g. something like <code class="docutils literal notranslate"><span class="pre">dot</span> <span class="pre">-Tpng</span> <span class="pre">-odfa.png</span> <span class="pre">dfa.dot</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-d</span> <span class="pre">--debug-output</span></code></dt><dd><p>Emit <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> in the generated code.
<code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> should be defined by the user in the form of a void function
with two parameters: <code class="docutils literal notranslate"><span class="pre">state</span></code> (lexer state or -1) and <code class="docutils literal notranslate"><span class="pre">symbol</span></code> (current
input symbol of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-adfa</span></code></dt><dd><p>Debug option: output DFA after tunneling (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-cfg</span></code></dt><dd><p>Debug option: output control flow graph of tag variables (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-closure-stats</span></code></dt><dd><p>Debug option: output statistics on the number of states in closure.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-det</span></code></dt><dd><p>Debug option: output DFA immediately after determinization (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-min</span></code></dt><dd><p>Debug option: output DFA after minimization (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-tagopt</span></code></dt><dd><p>Debug option: output DFA after tag optimizations (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-tree</span></code></dt><dd><p>Debug option: output DFA under construction with states represented as tag
history trees (in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-dfa-raw</span></code></dt><dd><p>Debug option: output DFA under construction with expanded state-sets
(in .dot format).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-interf</span></code></dt><dd><p>Debug option: output interference table produced by liveness analysis of tag
variables.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--dump-nfa</span></code></dt><dd><p>Debug option: output NFA (in .dot format).</p>
</dd>
</dl>
<p>Internal options:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">--dfa-minimization</span> <span class="pre">&lt;moore</span> <span class="pre">|</span> <span class="pre">table&gt;</span></code></dt><dd><p>Internal option: DFA minimization algorithm used by re2c. The <code class="docutils literal notranslate"><span class="pre">moore</span></code>
option is the Moore algorithm (it is the default). The <code class="docutils literal notranslate"><span class="pre">table</span></code> option is
the âtable fillingâ algorithm. Both algorithms should produce the same DFA
up to states relabeling; table filling is simpler and much slower and serves
as a reference implementation.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--eager-skip</span></code></dt><dd><p>Internal option: make the generated lexer advance the input position
eagerly â immediately after reading the input symbol. This changes the
default behavior when the input position is advanced lazily â after
transition to the next state. This option is implied by <code class="docutils literal notranslate"><span class="pre">--no-lookahead</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-lookahead</span></code></dt><dd><p>Internal option: use TDFA(0) instead of TDFA(1).
This option has effect only with <code class="docutils literal notranslate"><span class="pre">--tags</span></code> or <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> options.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--no-optimize-tags</span></code></dt><dd><p>Internal optionL: suppress optimization of tag variables (useful for
debugging).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-closure</span> <span class="pre">&lt;gor1</span> <span class="pre">|</span> <span class="pre">gtop&gt;</span></code></dt><dd><p>Internal option: specify shortest-path algorithm used for the construction of
epsilon-closure with POSIX disambiguation semantics: <code class="docutils literal notranslate"><span class="pre">gor1</span></code> (the default)
stands for Goldberg-Radzik algorithm, and <code class="docutils literal notranslate"><span class="pre">gtop</span></code> stands for âglobal
topological orderâ algorithm.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--posix-prectable</span> <span class="pre">&lt;complex</span> <span class="pre">|</span> <span class="pre">naive&gt;</span></code></dt><dd><p>Internal option: specify the algorithm used to compute POSIX precedence
table. The <code class="docutils literal notranslate"><span class="pre">complex</span></code> algorithm computes precedence table in one traversal
of tag history tree and has quadratic complexity in the number of TNFA
states; it is the default. The <code class="docutils literal notranslate"><span class="pre">naive</span></code> algorithm has worst-case cubic
complexity in the number of TNFA states, but it is much simpler than
<code class="docutils literal notranslate"><span class="pre">complex</span></code> and may be slightly faster in non-pathological cases.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--stadfa</span></code></dt><dd><p>Internal option:
use staDFA algorithm for submatch extraction. The main difference with TDFA
is that tag operations in staDFA are placed in states, not on transitions.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">--fixed-tags</span> <span class="pre">&lt;none</span> <span class="pre">|</span> <span class="pre">toplevel</span> <span class="pre">|</span> <span class="pre">all&gt;</span></code></dt><dd><p>Internal option:
specify whether the fixed-tag optimization should be applied to all tags
(<code class="docutils literal notranslate"><span class="pre">all</span></code>), none of them (<code class="docutils literal notranslate"><span class="pre">none</span></code>), or only those in toplevel concatenation
(<code class="docutils literal notranslate"><span class="pre">toplevel</span></code>). The default is <code class="docutils literal notranslate"><span class="pre">all</span></code>.
âFixedâ tags are those that are located within a fixed distance to some
other tag (called âbaseâ). In such cases only tha base tag needs to be
tracked, and the value of the fixed tag can be computed as the value of the
base tag plus a static offset. For tags that are under alternative or
repetition it is also necessary to check if the base tag has a no-match
value (in that case fixed tag should also be set to no-match, disregarding
the offset). For tags in top-level concatenation the check is not needed,
because they always match.</p>
</dd>
</dl>
</div>
<div class="section" id="warnings">
<h3>Warnings<a class="headerlink" href="#warnings" title="Permalink to this headline">Â¶</a></h3>
<p>See <a class="reference external" href="warnings/warnings.html">detailed descriptions with examples</a> for all warnings.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-W</span></code></dt><dd><p>Turn on all warnings.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Werror</span></code></dt><dd><p>Turn warnings into errors. Note that this option alone
doesnât turn on any warnings; it only affects those warnings that have
been turned on so far or will be turned on later.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-W&lt;warning&gt;</span></code></dt><dd><p>Turn on <code class="docutils literal notranslate"><span class="pre">warning</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wno-&lt;warning&gt;</span></code></dt><dd><p>Turn off <code class="docutils literal notranslate"><span class="pre">warning</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Werror-&lt;warning&gt;</span></code></dt><dd><p>Turn on <code class="docutils literal notranslate"><span class="pre">warning</span></code> and treat it as an error (this implies <code class="docutils literal notranslate"><span class="pre">-W&lt;warning&gt;</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wno-error-&lt;warning&gt;</span></code></dt><dd><p>Donât treat this particular <code class="docutils literal notranslate"><span class="pre">warning</span></code> as an error. This doesnât turn off
the warning itself.</p>
</dd>
</dl>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-Wcondition-order</span></code></dt><dd><p>Warn if the generated program makes implicit
assumptions about condition numbering. One should use either the <code class="docutils literal notranslate"><span class="pre">-t,</span> <span class="pre">--type-header</span></code> option or
the <code class="docutils literal notranslate"><span class="pre">/*!types:re2c*/</span></code> directive to generate a mapping of condition names to numbers and then use
the autogenerated condition names.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wempty-character-class</span></code></dt><dd><p>Warn if a regular expression contains an empty
character class. Trying to match an empty character class makes no sense: it should always fail.
However, for backwards compatibility reasons <code class="docutils literal notranslate"><span class="pre">re2c</span></code> allows empty character classes and
treats them as empty strings. Use the <code class="docutils literal notranslate"><span class="pre">--empty-class</span></code> option to change the default
behavior.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wmatch-empty-string</span></code></dt><dd><p>Warn if a rule is nullable (matches an empty string).
If the lexer runs in a loop and the empty match is unintentional,
the lexer may unexpectedly hang in an infinite loop.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wswapped-range</span></code></dt><dd><p>Warn if the lower bound of a range is greater than its upper
bound. The default behavior is to silently swap the range bounds.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wundefined-control-flow</span></code></dt><dd><p>Warn if some input strings cause undefined
control flow in the lexer (the faulty patterns are reported). This is the
most dangerous and most common mistake. It can be easily fixed by adding
the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code> which has the lowest priority, matches any code unit, and consumes
exactly one code unit.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wunreachable-rules</span></code></dt><dd><p>Warn about rules that are shadowed by other rules and will never match.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wuseless-escape</span></code></dt><dd><p>Warn if a symbol is escaped when it shouldnât be.
By default, re2c silently ignores such escapes, but this may as well indicate a
typo or an error in the escape sequence.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wnondeterministic-tags</span></code></dt><dd><p>Warn if a tag has <code class="docutils literal notranslate"><span class="pre">n</span></code>-th degree of nondeterminism, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is greater than 1.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-Wsentinel-in-midrule</span></code></dt><dd><p>Warn if the sentinel symbol occurs in the middle of a rule â this may
cause reads past the end of buffer, crashes or memory corruption in the
generated lexer. This warning is only applicable if the sentinel method of
checking for the end of input is used.
It is set to an error if <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code> configuration is used.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="program-interface">
<h2>Program interface<a class="headerlink" href="#program-interface" title="Permalink to this headline">Â¶</a></h2>
<p>Re2c has a flexible interface that gives the user both the freedom and the responsibility
to define how the generated code interacts with the outer program.
There are two major options:</p>
<ul>
<li><p><strong>Pointer API</strong>.
It is also called âdefault APIâ, since it was historically the first, and for a long time the only one.
This is a more restricted API based on C pointer arithmetics.
It consists of pointer-like primitives <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>, <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code> and <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>, which are normally defined as pointers
of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE*</span></code>.
Pointer API is enabled by default for the C backend,
and it cannot be used with other backends that do not have pointer arithmetics.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Generic API</strong>.
This is a less restricted API that does not assume pointer semantics.
It consists of primitives
<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code>,
<code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code> and
<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code>.
For the C backend generic API is enabled with <code class="docutils literal notranslate"><span class="pre">--input</span> <span class="pre">custom</span></code> option or
<code class="docutils literal notranslate"><span class="pre">re2c:flags:input</span> <span class="pre">=</span> <span class="pre">custom;</span></code> configuration;
for the Go backend it is enabled by default.
Generic API was added in version 0.14.
It is intentionally designed to give the user as much freedom as possible
in redefining the input model and the semantics of different actions performed
by the generated code. As an example, one can override <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> to check for
the end of input before reading the input character, or do some logging, etc.</p></li>
</ul>
<p>Generic API has two styles:</p>
<ul>
<li><p><strong>Function-like</strong>.
This style is enabled with <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span> <span class="pre">=</span> <span class="pre">functions;</span></code> configuration,
and it is the default for C backend. In this style API primitives should be
defined as functions or macros with parentheses, accepting the necessary
arguments. For example, in C the default pointer API can be defined in
function-like style generic API as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define  YYPEEK()                 *YYCURSOR</span>
<span class="cp">#define  YYSKIP()                 ++YYCURSOR</span>
<span class="cp">#define  YYBACKUP()               YYMARKER = YYCURSOR</span>
<span class="cp">#define  YYBACKUPCTX()            YYCTXMARKER = YYCURSOR</span>
<span class="cp">#define  YYRESTORE()              YYCURSOR = YYMARKER</span>
<span class="cp">#define  YYRESTORECTX()           YYCURSOR = YYCTXMARKER</span>
<span class="cp">#define  YYRESTORETAG(tag)        YYCURSOR = tag</span>
<span class="cp">#define  YYLESSTHAN(len)          YYLIMIT - YYCURSOR &lt; len</span>
<span class="cp">#define  YYSTAGP(tag)             tag = YYCURSOR</span>
<span class="cp">#define  YYSTAGN(tag)             tag = NULL</span>
<span class="cp">#define  YYSHIFT(shift)           YYCURSOR += shift</span>
<span class="cp">#define  YYSHIFTSTAG(tag, shift)  tag += shift</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Free-form</strong>.
This style is enabled with <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span> <span class="pre">=</span> <span class="pre">free-form;</span></code> configuration, and
it is the default for Go backend. In this style API primitives can be defined
as free-form pieces of code, and instead of arguments they have interpolated
variables of the form <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{name}</span></code>, or optionally just <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> if there is only one
argument. The <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> text is called âsigilâ. It can be redefined to any other
text with <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration. For example, the default pointer API
can be defined in free-form style generic API as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYPEEK</span>       <span class="o">=</span> <span class="s">&quot;*YYCURSOR&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYSKIP</span>       <span class="o">=</span> <span class="s">&quot;++YYCURSOR&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYBACKUP</span>     <span class="o">=</span> <span class="s">&quot;YYMARKER = YYCURSOR&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYBACKUPCTX</span>  <span class="o">=</span> <span class="s">&quot;YYCTXMARKER = YYCURSOR&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYRESTORE</span>    <span class="o">=</span> <span class="s">&quot;YYCURSOR = YYMARKER&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYRESTORECTX</span> <span class="o">=</span> <span class="s">&quot;YYCURSOR = YYCTXMARKER&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYRESTORETAG</span> <span class="o">=</span> <span class="s">&quot;YYCURSOR = ${tag}&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYLESSTHAN</span>   <span class="o">=</span> <span class="s">&quot;YYLIMIT - YYCURSOR &lt; @@{len}&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYSTAGP</span>      <span class="o">=</span> <span class="s">&quot;@@{tag} = YYCURSOR&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYSTAGN</span>      <span class="o">=</span> <span class="s">&quot;@@{tag} = NULL&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYSHIFT</span>      <span class="o">=</span> <span class="s">&quot;YYCURSOR += @@{shift}&quot;</span><span class="p">;</span>
<span class="nl">re2c</span><span class="p">:</span><span class="nl">define</span><span class="p">:</span><span class="n">YYSHIFTSTAG</span>  <span class="o">=</span> <span class="s">&quot;@@{tag} += @@{shift}&quot;</span><span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<div class="section" id="api-primitives">
<h3>API primitives<a class="headerlink" href="#api-primitives" title="Permalink to this headline">Â¶</a></h3>
<p>Here is a list of API primitives that may be used by the generated code in order to interface with the outer program.
Which primitives are needed depends on multiple factors, including
the complexity of regular expressions, input representation, buffering, the use of various features and so on.
All the necessary primitives should be defined by the user in the form of macros, functions, variables, free-form pieces of code or any other suitable form.
Re2c does not (and cannot) check the definitions, so if anything is missing or defined incorrectly the generated code will not compile.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code></dt><dd><p>The type of the input characters (code units).
For ASCII, EBCDIC and UTF-8 encodings it should be 1-byte unsigned integer.
For UTF-16 or UCS-2 it should be 2-byte unsigned integer. For UTF-32 it
should be 4-byte unsigned integer.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code></dt><dd><p>A pointer-like l-value that stores the current input position (usually a
pointer of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE*</span></code>). Initially <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> should point to the
first input character. It is advanced by the generated code.
When a rule matches, <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> points to the one after the last matched
character. It is used only in the default C API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code></dt><dd><p>A pointer-like r-value that stores the end of input position (usually a
pointer of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE*</span></code>). Initially <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> should point to the
one after the last available input character. It is not changed by the
generated code. Lexer compares <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> to <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>
in order to determine if there is enough input characters left.
<code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> is used only in the default C API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code></dt><dd><p>A pointer-like l-value (usually a pointer of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE*</span></code>) that stores
the position of the latest matched rule. It is used to restores <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code>
position if the longer match fails and lexer needs to rollback.
Initialization is not needed. <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code> is used only in the default C API.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code></dt><dd><p>A pointer-like l-value that stores the position of the trailing context
(usually a pointer of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE*</span></code>). No initialization is needed.
It is used only in the default C API, and only with the lookahead operator
<code class="docutils literal notranslate"><span class="pre">/</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYFILL</span></code></dt><dd><p>API primitive with one argument <code class="docutils literal notranslate"><span class="pre">len</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is to provide at least <code class="docutils literal notranslate"><span class="pre">len</span></code> more input
characters or fail. If EOF rule is used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> should always return to
the calling function; the return value should be zero on success and non-zero
on failure. If EOF rule is not used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> return value is ignored and
it should not return on failure. Maximal value of <code class="docutils literal notranslate"><span class="pre">len</span></code> is <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>,
which can be generated with <code class="docutils literal notranslate"><span class="pre">/*!max:re2c*/</span></code> directive. The definition of
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> can be either function-like or free-form depending on the API
style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL:naked</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code></dt><dd><p>An integral constant equal to the  maximal value of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> argument.
It can be generated with <code class="docutils literal notranslate"><span class="pre">/*!max:re2c*/</span></code> directive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">len</span></code>.
It should be defined as an r-value of boolean type that equals <code class="docutils literal notranslate"><span class="pre">true</span></code> if
and only if there is less than <code class="docutils literal notranslate"><span class="pre">len</span></code> input characters left.
The definition can be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code></dt><dd><p>A generic API primitive with no arguments.
It should be defined as an r-value of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> that is equal to the
character at the current input position. The definition can be either
function-like or free-form depending on the API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code></dt><dd><p>A generic API primitive with no arguments.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code> is to advance the current input position by one
character. The definition can be either function-like or free-form
depending on the API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code></dt><dd><p>A generic API primitive with no arguments.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code> is to save the current input position, which is
later restored with <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code></dt><dd><p>A generic API primitive with no arguments.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> is to restore the current input position to the
value saved by <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code></dt><dd><p>A generic API primitive with zero arguments.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code> is to save the current input position as the
position of the trailing context, which is later restored by <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code></dt><dd><p>A generic API primitive with no arguments.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code> is to restore the trailing context position
saved with <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code> is to restore the trailing context position
to the value of <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code> is to set <code class="docutils literal notranslate"><span class="pre">tag</span></code> value to the current input
position.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code> is to set <code class="docutils literal notranslate"><span class="pre">tag</span></code> value to null (or some default
value). The definition should be either function-like or free-form depending
on the API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code> is to append the current position to the history
of <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> is to append null (or some other default) value
to the history of <code class="docutils literal notranslate"><span class="pre">tag</span></code>.
The definition can be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code></dt><dd><p>A generic API primitive with one argument <code class="docutils literal notranslate"><span class="pre">shift</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code> is to shift the current input position by
<code class="docutils literal notranslate"><span class="pre">shift</span></code> characters (the shift value may be negative). The definition
can be either function-like or free-form depending on the API style
(see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code></dt><dd><p>A generic  API primitive with two arguments, <code class="docutils literal notranslate"><span class="pre">tag</span></code> and <code class="docutils literal notranslate"><span class="pre">shift</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code> is to shift <code class="docutils literal notranslate"><span class="pre">tag</span></code> by <code class="docutils literal notranslate"><span class="pre">shift</span></code> characters
(the shift value may be negative).
The definition can be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code></dt><dd><p>A generic API primitive with two arguments, <code class="docutils literal notranslate"><span class="pre">tag</span></code> and <code class="docutils literal notranslate"><span class="pre">shift</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code> is to shift the latest value in the history
of <code class="docutils literal notranslate"><span class="pre">tag</span></code> by <code class="docutils literal notranslate"><span class="pre">shift</span></code> characters (the shift value may be negative).
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code></dt><dd><p>An integral constant equal to the maximal number of POSIX capturing groups
in a rule. It is generated with <code class="docutils literal notranslate"><span class="pre">/*!maxnmatch:re2c*/</span></code> directive.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code></dt><dd><p>The type of the condition enum.
It should be generated either with <code class="docutils literal notranslate"><span class="pre">/*!types:re2c*/</span></code> directive or <code class="docutils literal notranslate"><span class="pre">-t</span></code>
<code class="docutils literal notranslate"><span class="pre">--type-header</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYGETCONDITION</span></code></dt><dd><p>An API primitive with zero arguments.
It should be defined as an r-value of type <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code> that is equal to
the current condition identifier. The definition can be either function-like
or free-form depending on the API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> and
<code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETCONDITION:naked</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSETCONDITION</span></code></dt><dd><p>An API primitive with one argument <code class="docutils literal notranslate"><span class="pre">cond</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSETCONDITION</span></code> is to set the current condition identifier
to <code class="docutils literal notranslate"><span class="pre">cond</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION&#64;cond</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code></dt><dd><p>An API primitive with zero arguments.
It should be defined as an r-value of integer type that is equal to the
current lexer state. Should be initialized to <code class="docutils literal notranslate"><span class="pre">-1</span></code>. The definition can be
either function-like or free-form depending on the API style (see
<code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETSTATE:naked</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code></dt><dd><p>An API primitive with one argument <code class="docutils literal notranslate"><span class="pre">state</span></code>.
The meaning of <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code> is to set the current lexer state to <code class="docutils literal notranslate"><span class="pre">state</span></code>.
The definition should be either function-like or free-form depending on the
API style (see <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE&#64;state</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code></dt><dd><p>A debug API primitive with two arguments. It can be used to debug the
generated code (with <code class="docutils literal notranslate"><span class="pre">-d</span></code> <code class="docutils literal notranslate"><span class="pre">--debug-output</span></code> option). <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> should
return no value and accept two arguments: <code class="docutils literal notranslate"><span class="pre">state</span></code> (either a DFA state
index or <code class="docutils literal notranslate"><span class="pre">-1</span></code>) and <code class="docutils literal notranslate"><span class="pre">symbol</span></code> (the current input symbol).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yych</span></code></dt><dd><p>An l-value of type <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> that stores the current input character.
User definition is necessary only with <code class="docutils literal notranslate"><span class="pre">-f</span></code> <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yyaccept</span></code></dt><dd><p>An l-value of unsigned integral type that stores the number of the latest
matched rule.
User definition is necessary only with <code class="docutils literal notranslate"><span class="pre">-f</span></code> <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yynmatch</span></code></dt><dd><p>An l-value of unsigned integral type that stores the number of POSIX
capturing groups in the matched rule.
Used only with <code class="docutils literal notranslate"><span class="pre">-P</span></code> <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">yypmatch</span></code></dt><dd><p>An array of l-values that are used to hold the tag values corresponding
to the capturing parentheses in the matching rule. Array length must be
at least <code class="docutils literal notranslate"><span class="pre">yynmatch</span> <span class="pre">*</span> <span class="pre">2</span></code> (usually <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span> <span class="pre">*</span> <span class="pre">2</span></code> is a good choice).
Used only with <code class="docutils literal notranslate"><span class="pre">-P</span></code> <code class="docutils literal notranslate"><span class="pre">--posix-captures</span></code> option.</p>
</dd>
</dl>
</div>
<div class="section" id="directives">
<h3>Directives<a class="headerlink" href="#directives" title="Permalink to this headline">Â¶</a></h3>
<p>Below is the list of all directives provided by re2c (in no particular order).
More information on each directive can be found in the related sections.</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">/*!re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>A standard re2c block.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">%{</span> <span class="pre">...</span> <span class="pre">%}</span></code></dt><dd><p>A standard re2c block in <code class="docutils literal notranslate"><span class="pre">-F</span> <span class="pre">--flex-support</span></code> mode.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!rules:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>A reusable re2c block (requires <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reuse</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!use:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>A block that reuses previous rules-block specified with
<code class="docutils literal notranslate"><span class="pre">/*!rules:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code> (requires <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reuse</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!ignore:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>A block which contents are ignored and cut off from the output file.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!max:re2c*/</span></code></dt><dd><p>This directive is substituted with the macro-definition of <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!maxnmatch:re2c*/</span></code></dt><dd><p>This directive is substituted with the macro-definition of <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code>
(requires <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!getstate:re2c*/</span></code></dt><dd><p>This directive is substituted with conditional dispatch on lexer state
(requires <code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">--storable-state</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!types:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>This directive is substituted with the definition of condition <code class="docutils literal notranslate"><span class="pre">enum</span></code>
(requires <code class="docutils literal notranslate"><span class="pre">-c</span> <span class="pre">--conditions</span></code> option).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!stags:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code>, <code class="docutils literal notranslate"><span class="pre">/*!mtags:re2c</span> <span class="pre">...</span> <span class="pre">*/</span></code></dt><dd><p>These directives allow one to specify a template piece of code that is expanded
for each s-tag/m-tag variable generated by re2c. This block has two optional
configurations: <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">=</span> <span class="pre">&quot;&#64;&#64;&quot;;</span></code> (specifies the template where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> is
substituted with the name of each tag variable), and <code class="docutils literal notranslate"><span class="pre">separator</span> <span class="pre">=</span> <span class="pre">&quot;&quot;;</span></code>
(specifies the piece of code used to join the generated pieces for different
tag variables).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">FILE</span> <span class="pre">*/</span></code></dt><dd><p>This directive allows one to include <code class="docutils literal notranslate"><span class="pre">FILE</span></code> (the contents of the <code class="docutils literal notranslate"><span class="pre">FILE</span></code>
are literally substituted in place of the directive, in the same way as
<code class="docutils literal notranslate"><span class="pre">#include</span></code> works in C/C++). This directive can be used together with the
<code class="docutils literal notranslate"><span class="pre">--depfile</span></code> option to generate build system dependencies on the included
files.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!include</span> <span class="pre">FILE</span> <span class="pre">;</span></code></dt><dd><p>This directive is the same as <code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">FILE</span> <span class="pre">*/</span></code>, except that it is
meant to be used inside of a re2c block (and therefore has a slightly
different syntax).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!header:re2c:on*/</span></code></dt><dd><p>This directive marks the start of header file. Everything after it and up to
the following <code class="docutils literal notranslate"><span class="pre">/*!header:re2c:off*/</span></code> directive is processed by re2c and
written to the header file specified with <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">--type-header</span></code> option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">/*!header:re2c:off*/</span></code></dt><dd><p>This directive marks the end of header file started with
<code class="docutils literal notranslate"><span class="pre">/*!header:re2c:on*/</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="configurations">
<h3>Configurations<a class="headerlink" href="#configurations" title="Permalink to this headline">Â¶</a></h3>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:t</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:type-header</span></code></dt><dd><p>Specify the name of the generated header file relative to the directory of
the output file. (Same as <code class="docutils literal notranslate"><span class="pre">-t</span></code>, <code class="docutils literal notranslate"><span class="pre">--type-header</span></code> command-line option
except that the filepath is relative.)</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:input</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--input</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code></dt><dd><p>Allows one to specify the style of generic API. Possible values are <code class="docutils literal notranslate"><span class="pre">functions</span></code>
and <code class="docutils literal notranslate"><span class="pre">free-form</span></code>. With <code class="docutils literal notranslate"><span class="pre">functions</span></code> style (the default for the C backend)
API primitives behave like functions, and re2c generates parentheses with an
argument list after the name of each primitive.
With <code class="docutils literal notranslate"><span class="pre">free-form</span></code> style (the default for the Go backend) re2c treats API
definitions as interpolated strings and substitutes argument placeholders
with the actual argument values.
This option can be overridden by options for individual API primitives,
e.g. <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL:naked</span></code> for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code></dt><dd><p>Allows one to specify the âsigilâ symbol (or string) that is used to recognize
argument placeholders in the definitions of generic API primitives.
The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Placeholders start with sigil, followed by the argument name in curly braces.
For example, if sigil is set to <code class="docutils literal notranslate"><span class="pre">$</span></code>, then placeholders will have the form
<code class="docutils literal notranslate"><span class="pre">${name}</span></code>. Single-argument APIs may use shorthand notation without the
name in braces. This option can be overridden by options for individual API
primitives, e.g. <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL&#64;len</span></code> for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYCTYPE</span></code></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYCURSOR</span></code></dt><dd><p>Defines C API primitive <code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYLIMIT</span></code></dt><dd><p>Defines C API primitive <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYMARKER</span></code></dt><dd><p>Defines C API primitive <code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYCTXMARKER</span></code></dt><dd><p>Defines C API primitive <code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL&#64;len</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
definition. Defaults to <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL:naked</span></code></dt><dd><p>Allows one to override <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> for <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.
Value <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span></code></dt><dd><p>Defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code> (<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is enabled). Set this to zero to suppress the
generation of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>. Use warnings (<code class="docutils literal notranslate"><span class="pre">-W</span></code> option) and <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code>
configuration to verify that the generated lexer cannot read past the end of
input, as this might introduce severe security issues to your programs.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:parameter</span></code></dt><dd><p>Controls the argument in the parentheses that follow <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>. Defaults to
<code class="docutils literal notranslate"><span class="pre">1</span></code>, which means that the argument is generated. If zero, the argument is
omitted. Can be overridden with <code class="docutils literal notranslate"><span class="pre">re2c:define:YYFILL:naked</span></code> or
<code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code></dt><dd><p>Specifies the sentinel symbol used with EOF rule <code class="docutils literal notranslate"><span class="pre">$</span></code> to check for the end
of input in the generated lexer. The default value is <code class="docutils literal notranslate"><span class="pre">-1</span></code> (EOF rule is not
used). Other possible values include all valid code units. Only decimal
numbers are recognized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code></dt><dd><p>Specifies the sentinel symbol used with the sentinel method of checking for
the end of input in the generated lexer (the case when bounds checking
is disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> and EOF rule <code class="docutils literal notranslate"><span class="pre">$</span></code> is not
used). This configuration does not affect code generation. It is used by
re2c to verify that the sentinel symbol is not allowed in the middle of the
rule, and prevent possible reads past the end of buffer in the generated
lexer. The default value is <code class="docutils literal notranslate"><span class="pre">-1</span></code> (re2c assumes that
the sentinel symbol is <code class="docutils literal notranslate"><span class="pre">0</span></code>, which is the most common case). Other
possible values include all valid code units. Only decimal numbers are
recognized.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYLESSTHAN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yyfill:check</span></code></dt><dd><p>Setting this to zero allows to suppress the generation of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> check
(<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> in generic API of <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code>-based comparison in default C
API). This configuration is useful when the necessary input is always
available. it defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code> (the check is generated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:yyFillLabel</span></code></dt><dd><p>Allows one to change the prefix of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> labels (used with EOF rule
or with storable states).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYPEEK</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSKIP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYBACKUP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYBACKUPCTX</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORE</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORECTX</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYRESTORETAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYRESTORETAG</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFT</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFT</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFTMTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFTMTAG</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSHIFTSTAG</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSHIFTSTAG</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSTAGN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSTAGP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYMTAGN</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYMTAGP</span></code></dt><dd><p>Defines generic API primitive <code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:T</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:tags</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-T</span> <span class="pre">--tags</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:P</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:posix-captures</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags:expression</span></code></dt><dd><p>Allows one to customize the way re2c addresses tag variables.
By default re2c generates expressions of the form <code class="docutils literal notranslate"><span class="pre">yyt&lt;N&gt;</span></code>. This might
be inconvenient, for example if tag variables are defined as fields in a
struct. Re2c recognizes placeholder of the form <code class="docutils literal notranslate"><span class="pre">&#64;&#64;{tag}</span></code> or <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> and
replaces it with the actual tag name.
Sigil <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code> can be redefined with <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.
For example, setting <code class="docutils literal notranslate"><span class="pre">re2c:tags:expression</span> <span class="pre">=</span> <span class="pre">&quot;p-&gt;&#64;&#64;&quot;;</span></code> results in
expressions of the form <code class="docutils literal notranslate"><span class="pre">p-&gt;yyt&lt;N&gt;</span></code> in the generated code.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:tags:prefix</span></code></dt><dd><p>Allows one to override the prefix of tag variables (defaults to <code class="docutils literal notranslate"><span class="pre">yyt</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:lookahead</span></code></dt><dd><p>Same as inverted <code class="docutils literal notranslate"><span class="pre">--no-lookahead</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:optimize-tags</span></code></dt><dd><p>Same as inverted <code class="docutils literal notranslate"><span class="pre">--no-optimize-tags</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYCONDTYPE</span></code></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETCONDITION</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYGETCONDITION</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETCONDITION:naked</span></code></dt><dd><p>Allows one to override <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> for <code class="docutils literal notranslate"><span class="pre">YYGETCONDITION</span></code>.
Value <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYSETCONDITION</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYSETCONDITION</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETCONDITION:naked</span></code></dt><dd><p>Allows one to override <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> for <code class="docutils literal notranslate"><span class="pre">YYSETCONDITION</span></code>.
Value <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code></dt><dd><p>Allows one to customize the goto statements used with the shortcut <code class="docutils literal notranslate"><span class="pre">:=&gt;</span></code>
rules in conditions. The default value is <code class="docutils literal notranslate"><span class="pre">goto</span> <span class="pre">&#64;&#64;;</span></code>.
Placeholders are substituted with condition name (see <code class="docutils literal notranslate"><span class="pre">re2c:api;sigil</span></code> and
<code class="docutils literal notranslate"><span class="pre">re2c:cond:goto&#64;cond</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:goto&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:divider</span></code></dt><dd><p>Defines the divider for condition blocks.
The default value is <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">***********************************</span> <span class="pre">*/</span></code>.
Placeholders are substituted with condition name (see <code class="docutils literal notranslate"><span class="pre">re2c:api;sigil</span></code> and
<code class="docutils literal notranslate"><span class="pre">re2c:cond:divider&#64;cond</span></code>).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cond:divider&#64;cond</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">re2c:cond:divider</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:condprefix</span></code></dt><dd><p>Specifies the prefix used for condition labels.
The default value is <code class="docutils literal notranslate"><span class="pre">yyc_</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:condenumprefix</span></code></dt><dd><p>Specifies the prefix used for condition identifiers.
The default value is <code class="docutils literal notranslate"><span class="pre">yyc</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETSTATE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYGETSTATE:naked</span></code></dt><dd><p>Allows one to override <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> for <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>.
Value <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE</span></code></dt><dd><p>Defines API primitive <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE&#64;state</span></code></dt><dd><p>Specifies the sigil used for argument substitution in <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>
definition. The default value is <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>.
Overrides the more generic <code class="docutils literal notranslate"><span class="pre">re2c:api:sigil</span></code> configuration.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYSETSTATE:naked</span></code></dt><dd><p>Allows one to override <code class="docutils literal notranslate"><span class="pre">re2c:api:style</span></code> for <code class="docutils literal notranslate"><span class="pre">YYSETSTATE</span></code>.
Value <code class="docutils literal notranslate"><span class="pre">0</span></code> corresponds to free-form API style.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:state:abort</span></code></dt><dd><p>If set to a positive integer value, changes the form of the <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code>
switch: instead of using default case to jump to the beginning of the lexer
block, a <code class="docutils literal notranslate"><span class="pre">-1</span></code> case is used, and the default case aborts the program.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:state:nextlabel</span></code></dt><dd><p>With storable states, allows to control if the <code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> block is
followed by a <code class="docutils literal notranslate"><span class="pre">yyNext</span></code> label (the default value is zero, which corresponds
to no label). Instead of using <code class="docutils literal notranslate"><span class="pre">yyNext</span></code> it is possible to use
<code class="docutils literal notranslate"><span class="pre">re2c:startlabel</span></code> to force the generation of a specific start label.
Instead of using labels it is often more convenient to generate
<code class="docutils literal notranslate"><span class="pre">YYGETSTATE</span></code> code using <code class="docutils literal notranslate"><span class="pre">/*!getstate:re2c*/</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:label:yyNext</span></code></dt><dd><p>Allows one to change the name of the <code class="docutils literal notranslate"><span class="pre">yyNext</span></code> label.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:startlabel</span></code></dt><dd><p>Controls the generation of start label for the next lexer block.
The default value is zero, which means that the start label is generated
only if it is used. An integer value greater than zero forces the generation
of start label even if it is unused by the lexer. A string value also forces
start label generation and sets the label name to the specified string.
This configuration applies only to the current block (it is reset to default
for the next block).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:s</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:nested-ifs</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-s</span> <span class="pre">--nested-ifs</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:b</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:bit-vectors</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-b</span> <span class="pre">--bit-vectors</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yybm</span></code></dt><dd><p>Overrides the name of the <code class="docutils literal notranslate"><span class="pre">yybm</span></code> variable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yybm:hex</span></code></dt><dd><p>Defaults to zero (a decimal bitmap table is generated). If set to nonzero,
a hexadecimal table is generated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:g</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:computed-gotos</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-g</span> <span class="pre">--computed-gotos</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:cgoto:threshold</span></code></dt><dd><p>With <code class="docutils literal notranslate"><span class="pre">-g</span></code> <code class="docutils literal notranslate"><span class="pre">--computed-gotos</span></code> option this value specifies
the complexity threshold that triggers the generation of jump tables instead
of nested <code class="docutils literal notranslate"><span class="pre">if</span></code> statements and bitmaps. The default value is <code class="docutils literal notranslate"><span class="pre">9</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:case-ranges</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--case-ranges</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:e</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:ecb</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-e</span> <span class="pre">--ecb</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:8</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:utf-8</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-8</span> <span class="pre">--utf-8</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:w</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:wide-chars</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-w</span> <span class="pre">--wide-chars</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:x</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:utf-16</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-x</span> <span class="pre">--utf-16</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:u</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:unicode</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-u</span> <span class="pre">--unicode</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:encoding-policy</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--encoding-policy</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:empty-class</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--empty-class</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:case-insensitive</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--case-insensitive</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:case-inverted</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--case-inverted</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:i</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:no-debug-info</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-i</span> <span class="pre">--no-debug-info</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:indent:string</span></code></dt><dd><p>Specifies the string to use for indentation.
The default value is <code class="docutils literal notranslate"><span class="pre">&quot;\t&quot;</span></code>.
Indent string should contain only whitespace characters.
To disable indentation entirely, set this configuration to empty
string <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:indent:top</span></code></dt><dd><p>Specifies the minimum amount of indentation to use.
The default value is zero.
The value should be a non-negative integer number.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:labelprefix</span></code></dt><dd><p>Allows one to change the prefix of DFA state labels.
The default value is <code class="docutils literal notranslate"><span class="pre">yy</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych:emit</span></code></dt><dd><p>Set this to zero to suppress the generation of <code class="docutils literal notranslate"><span class="pre">yych</span></code> definition.
Defaults to <code class="docutils literal notranslate"><span class="pre">1</span></code> (the definition is generated).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yych</span></code></dt><dd><p>Overrides the name of the <code class="docutils literal notranslate"><span class="pre">yych</span></code> variable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:yych:conversion</span></code></dt><dd><p>If set to nonzero, re2c automatically generates a cast to <code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code>
every time <code class="docutils literal notranslate"><span class="pre">yych</span></code> is read. Defaults to zero (no cast).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yyaccept</span></code></dt><dd><p>Overrides the name of the <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code> variable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yytarget</span></code></dt><dd><p>Overrides the name of the <code class="docutils literal notranslate"><span class="pre">yytarget</span></code> variable.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yystable</span></code></dt><dd><p>Deprecated.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:variable:yyctable</span></code></dt><dd><p>When both <code class="docutils literal notranslate"><span class="pre">-c</span></code> <code class="docutils literal notranslate"><span class="pre">--conditions</span></code> and <code class="docutils literal notranslate"><span class="pre">-g</span></code> <code class="docutils literal notranslate"><span class="pre">--computed-gotos</span></code> are active,
re2c will use this variable to generate a static jump table
for <code class="docutils literal notranslate"><span class="pre">YYGETCONDITION</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:define:YYDEBUG</span></code></dt><dd><p>Defines <code class="docutils literal notranslate"><span class="pre">YYDEBUG</span></code> (see the user interface section).</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:d</span></code>, <code class="docutils literal notranslate"><span class="pre">re2c:flags:debug-output</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">-d</span> <span class="pre">--debug-output</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:dfa-minimization</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--dfa-minimization</span></code> command-line option.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">re2c:flags:eager-skip</span></code></dt><dd><p>Same as <code class="docutils literal notranslate"><span class="pre">--eager-skip</span></code> command-line option.</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="regular-expressions">
<h2>Regular expressions<a class="headerlink" href="#regular-expressions" title="Permalink to this headline">Â¶</a></h2>
<p>re2c uses the following syntax for regular expressions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span></code> case-sensitive string literal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'foo'</span></code> case-insensitive string literal</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[a-xyz]</span></code>, <code class="docutils literal notranslate"><span class="pre">[^a-xyz]</span></code> character class (possibly negated)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.</span></code> any character except newline</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">\</span> <span class="pre">S</span></code> difference of character classes <code class="docutils literal notranslate"><span class="pre">R</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R*</span></code> zero or more occurrences of <code class="docutils literal notranslate"><span class="pre">R</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R+</span></code> one or more occurrences of <code class="docutils literal notranslate"><span class="pre">R</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R?</span></code> optional <code class="docutils literal notranslate"><span class="pre">R</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R{n}</span></code> repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> exactly <code class="docutils literal notranslate"><span class="pre">n</span></code> times</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R{n,}</span></code> repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> at least <code class="docutils literal notranslate"><span class="pre">n</span></code> times</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R{n,m}</span></code> repetition of <code class="docutils literal notranslate"><span class="pre">R</span></code> from <code class="docutils literal notranslate"><span class="pre">n</span></code> to <code class="docutils literal notranslate"><span class="pre">m</span></code> times</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(R)</span></code> just <code class="docutils literal notranslate"><span class="pre">R</span></code>; parentheses are used to override precedence or for POSIX-style submatch</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">S</span></code> concatenation: <code class="docutils literal notranslate"><span class="pre">R</span></code> followed by <code class="docutils literal notranslate"><span class="pre">S</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">|</span> <span class="pre">S</span></code> alternative: <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">or</span> <span class="pre">S</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">/</span> <span class="pre">S</span></code> lookahead: <code class="docutils literal notranslate"><span class="pre">R</span></code> followed by <code class="docutils literal notranslate"><span class="pre">S</span></code>, but <code class="docutils literal notranslate"><span class="pre">S</span></code> is not consumed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> the regular expression defined as <code class="docutils literal notranslate"><span class="pre">name</span></code> (or literal string <code class="docutils literal notranslate"><span class="pre">&quot;name&quot;</span></code> in Flex compatibility mode)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{name}</span></code> the regular expression defined as <code class="docutils literal notranslate"><span class="pre">name</span></code> in Flex compatibility mode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> an <em>s-tag</em>: saves the last input position at which <code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> matches in a variable named <code class="docutils literal notranslate"><span class="pre">stag</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">#mtag</span></code> an <em>m-tag</em>: saves all input positions at which <code class="docutils literal notranslate"><span class="pre">#mtag</span></code> matches in a variable named <code class="docutils literal notranslate"><span class="pre">mtag</span></code></p></li>
</ul>
<p>Character classes and string literals may contain the following escape sequences:
<code class="docutils literal notranslate"><span class="pre">\a</span></code>, <code class="docutils literal notranslate"><span class="pre">\b</span></code>, <code class="docutils literal notranslate"><span class="pre">\f</span></code>, <code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"><span class="pre">\r</span></code>, <code class="docutils literal notranslate"><span class="pre">\t</span></code>, <code class="docutils literal notranslate"><span class="pre">\v</span></code>, <code class="docutils literal notranslate"><span class="pre">\\</span></code>, octal escapes <code class="docutils literal notranslate"><span class="pre">\ooo</span></code> and hexadecimal escapes <code class="docutils literal notranslate"><span class="pre">\xhh</span></code>, <code class="docutils literal notranslate"><span class="pre">\uhhhh</span></code> and <code class="docutils literal notranslate"><span class="pre">\Uhhhhhhhh</span></code>.</p>
</div>
<div class="section" id="handling-the-end-of-input">
<h2>Handling the end of input<a class="headerlink" href="#handling-the-end-of-input" title="Permalink to this headline">Â¶</a></h2>
<p>One of the main problems for the lexer is to know when to stop.
There are a few terminating conditions:</p>
<ul class="simple">
<li><p>the lexer may match some rule (including default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>) and come to a final state</p></li>
<li><p>the lexer may fail to match any rule and come to a default state</p></li>
<li><p>the lexer may reach the end of input</p></li>
</ul>
<p>The first two conditions terminate the lexer in a ânaturalâ way:
it comes to a state with no outgoing transitions, and the matching automatically stops.
The third condition, end of input, is different: it may happen in any state, and the lexer should be able to handle it.
Checking for the end of input interrupts the normal lexer workflow
and adds conditional branches to the generated program, therefore it is necessary to minimize the number of such checks.
re2c supports a few different methods for end of input handling.
Which one to use depends on the complexity of regular expressions, the need for buffering, performance considerations and other factors.
Here is a list of all methods:</p>
<ul>
<li><p><strong>Sentinel character.</strong>
This method eliminates the need for the end of input checks altogether.
It is simple and efficient, but limited to the case when there is a natural âsentinelâ character that can never occur in valid input.
This character may still occur in invalid input, but it is not allowed by the regular expressions, except perhaps as the last character of a rule.
The sentinel character is appended at the end of input and serves as a stop signal:
when the lexer reads it, it must be either the end of input, or a syntax error.
In both cases the lexer stops.
This method is used if <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> and <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> has the default value -1.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Sentinel character with bounds checks.</strong>
This method is generic: it allows to handle any input without restrictions on the regular expressions.
The idea is to reduce the number of end of input checks by performing them only on certain characters.
Similar to the âsentinel characterâ method, one of the characters is chosen as a âsentinelâ and appended at the end of input.
However, there is no restriction on where the sentinel character may occur (in fact, any character can be chosen for a sentinel).
When the lexer reads this character, it additionally performs a bounds check.
If the current position is within bounds, the lexer will resume matching and handle the sentinel character as a regular one.
Otherwise it will try to get more input with <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> (unless <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is disabled).
If more input is available, the lexer will rematch the last character and continue as if the sentinel never occurred.
Otherwise it is the real end of input, and the lexer will stop.
This method is used if <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> has non-negative value (it should be set to the ordinal of the sentinel character).
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> must be either defined or disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Bounds checks with padding.</strong>
This method is the default one.
It is generic, and it is usually faster than the âsentinel character with bounds checksâ method, but also more complex to use.
The idea is to partition the underlying finite-state automaton into strongly connected components (SCCs),
and generate only one bounds check per SCC, but make it check for multiple characters at once
(enough to cover the longest non-looping path in the SCC).
This way the checks are less frequent, which makes the lexer run much faster.
If a check shows that there is not enough input, the lexer will invoke <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>,
which may either supply enough input or else it should not return (in the latter case the lexer will stop).
This approach has a problem with matching short lexemes at the end of input,
because the multi-character check requires enough characters to cover the longest possible lexeme.
To fix this problem, it is necessary to append a few fake characters at the end of input.
The padding should not form a valid lexeme suffix to avoid fooling the lexer into matching it as part of the input.
The minimum sufficient length of padding is <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> and it is autogenerated by re2c with <code class="docutils literal notranslate"><span class="pre">/*!max:re2c*/</span></code>.
This method is used if <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span></code> has the default nonzero value, and <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> has the default value -1.
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> must be defined.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p><strong>Custom methods with generic API.</strong>
Generic API allows to override basic operations like reading a character,
which makes it possible to include the end of input checks as part of them.
Such methods are error-prone and should be used with caution, only if other methods cannot be used.
These methods are used if generic API is enabled with <code class="docutils literal notranslate"><span class="pre">--input</span> <span class="pre">custom</span></code> or <code class="docutils literal notranslate"><span class="pre">re2c:flags:input</span> <span class="pre">=</span> <span class="pre">custom;</span></code>
and default bounds checks are disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code>.
Note that the use of generic API does not imply the use of custom methods, it merely allows it.</p></li>
</ul>
<p>The following subsections contain an example of each method.</p>
<div class="section" id="sentinel-character">
<h3>Sentinel character<a class="headerlink" href="#sentinel-character" title="Permalink to this headline">Â¶</a></h3>
<p>In this example the lexer uses a sentinel character to handle the end of input.
The program counts space-separated words in a null-terminated string.
Configuration <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code> suppresses the generation of bounds checks and <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocations.
The sentinel character is null.
It is the last character of each input string,
and it is not allowed in the middle of a lexeme by any of the rules
(in particular, it is not included in the character ranges, where it is easy to overlook).
If a null occurs in the middle of a string, it is a syntax error and the lexer will match default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>, but it wonât read past the end of input or crash.
<a class="reference external" href="https://re2c.org/manual/warnings/warnings.html#wsentinel-in-midrule">-Wsentinel-in-midrule</a>
warning verifies that the rules do not allow sentinel in the middle
(it is possible to tell re2c which character is used as a sentinel with <code class="docutils literal notranslate"><span class="pre">re2c:sentinel</span></code> configuration â
the default assumption is null, since this is the most common case).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="c1">// expect a null-terminated string</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>

<span class="cm">    *      { return -1; }</span>
<span class="cm">    [\x00] { return count; }</span>
<span class="cm">    [a-z]+ { ++count; goto loop; }</span>
<span class="cm">    [ ]+   { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;one two three&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;f0ur&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sentinel-character-with-bounds-checks">
<h3>Sentinel character with bounds checks<a class="headerlink" href="#sentinel-character-with-bounds-checks" title="Permalink to this headline">Â¶</a></h3>
<p>In this example the lexer uses sentinel character with bounds checks to handle the end of input
(this method was added in version 1.2).
The program counts single-quoted strings separated with spaces.
The sentinel character is null, which is specified with <code class="docutils literal notranslate"><span class="pre">re2c:eof</span> <span class="pre">=</span> <span class="pre">0;</span></code> configuration.
Null is the last character of each input string â this is essential to detect the end of input.
Null, as well as any other character, is allowed in the middle of a rule
(for example, <code class="docutils literal notranslate"><span class="pre">'aaa\0aa'\0</span></code> is valid input, but <code class="docutils literal notranslate"><span class="pre">'aaa\0</span></code> is a syntax error).
Bounds checks are generated in each state that has a switch on an input character,
in the conditional branch that corresponds to null
(that branch may also cover other characters â
re2c does not split out a separate branch for sentinel,
because increasing the number of branches degrades performance more than bounds checks do).
Bounds checks are of the form <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span> <span class="pre">&lt;=</span> <span class="pre">YYCURSOR</span></code> or <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(1)</span></code> with generic API.
If a bounds check succeeds, the lexer will continue matching.
If a bounds check fails, the lexer has reached the end of input, and it should stop.
In this example <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is disabled with <code class="docutils literal notranslate"><span class="pre">re2c:yyfill:enable</span> <span class="pre">=</span> <span class="pre">0;</span></code>
and the lexer does not attempt to get more input
(see another example that uses <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> in the <a class="reference internal" href="#yyfill-with-sentinel-character">YYFILL with sentinel character</a> section).
When the end of input has been reached, there are three possibilities:
if the lexer is in the initial state, it will match the end of input rule <code class="docutils literal notranslate"><span class="pre">$</span></code>,
otherwise it will either fallback to a previously matched rule (including default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>)
or go to a default state, causing
<a class="reference external" href="https://re2c.org/manual/warnings/warnings.html#wundefined-control-flow">-Wundefined-control-flow</a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="c1">// expect a null-terminated string</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span> <span class="o">=</span> <span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">YYLIMIT</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">loop</span><span class="p">:</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:eof = 0;</span>

<span class="cm">    *                           { return -1; }</span>
<span class="cm">    $                           { return count; }</span>
<span class="cm">    [&#39;] ([^&#39;\\] | [\\][^])* [&#39;] { ++count; goto loop; }</span>
<span class="cm">    [ ]+                        { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="cp">#define TEST(s, r) assert(lex(s, sizeof(s) - 1) == r)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;unterminated</span><span class="se">\\</span><span class="s">&#39;&quot;</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="bounds-checks-with-padding">
<h3>Bounds checks with padding<a class="headerlink" href="#bounds-checks-with-padding" title="Permalink to this headline">Â¶</a></h3>
<p>In this example the lexer uses bounds checking with padding to handle the end of input (it is the default method).
The program counts single-quoted strings separated with spaces.
There is a padding of <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> null characters appended at the end of input,
where <code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> value is autogenerated with <code class="docutils literal notranslate"><span class="pre">/*!max:re2c*/</span></code> directive.
It is not necessary to use null for padding â any characters can be used, as long as they do not form a valid lexeme suffix
(in this example padding should not contain single quotes, as they may be mistaken for a suffix of a single-quoted string).
There is a âstopâ rule that matches the first padding character (null) and terminates the lexer
(it returns success only if it has matched at the beginning of padding, otherwise a stray null is syntax error).
Bounds checks are generated only in some states that depend on the strongly connected components of the underlying automaton.
They are of the form <code class="docutils literal notranslate"><span class="pre">(YYLIMIT</span> <span class="pre">-</span> <span class="pre">YYCURSOR)</span> <span class="pre">&lt;</span> <span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(n)</span></code> with generic API,
where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the minimum number of characters that are needed for the lexer to proceed
(it also means that the next bounds check will occur in at most <code class="docutils literal notranslate"><span class="pre">n</span></code> characters).
If a bounds check succeeds, the lexer will continue matching.
If a bounds check fails, the lexer has reached the end of input and will invoke <code class="docutils literal notranslate"><span class="pre">YYFILL(n)</span></code>,
which should either supply at least <code class="docutils literal notranslate"><span class="pre">n</span></code> input characters, or it should not return.
In this example <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> always fails and terminates the lexer with an error.
This is fine, because in this example <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> can only be called when the lexer has advanced into the padding,
which means that is has encountered an unterminated string and should return a syntax error.
See the <a class="reference internal" href="#yyfill-with-padding">YYFILL with padding</a> section for an example that refills the input buffer with <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/*!max:re2c*/</span>

<span class="c1">// expect YYMAXFILL-padded string</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span> <span class="o">=</span> <span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">YYLIMIT</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">YYMAXFILL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">loop</span><span class="p">:</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>
<span class="cm">    re2c:define:YYFILL = &quot;return -1;&quot;;</span>

<span class="cm">    *                           { return -1; }</span>
<span class="cm">    [\x00]                      { return YYCURSOR + YYMAXFILL - 1 == YYLIMIT ? count : -1; }</span>
<span class="cm">    [&#39;] ([^&#39;\\] | [\\][^])* [&#39;] { ++count; goto loop; }</span>
<span class="cm">    [ ]+                        { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="c1">// make a copy of the string with YYMAXFILL zeroes at the end</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="n">YYMAXFILL</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">YYMAXFILL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">lex</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TEST(s, r) test(s, sizeof(s) - 1, r)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;unterminated</span><span class="se">\\</span><span class="s">&#39;&quot;</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="custom-methods-with-generic-api">
<h3>Custom methods with generic API<a class="headerlink" href="#custom-methods-with-generic-api" title="Permalink to this headline">Â¶</a></h3>
<p>In this example the lexer uses a custom end of input handling method based on generic API.
The program counts single-quoted strings separated with spaces.
It is the same as the <a class="reference internal" href="#sentinel-character-with-bounds-checks">sentinel character with bounds checks</a> example,
except that the input is not null-terminated
(so this method can be used if itâs not possible to have any padding at all, not even a single sentinel character).
To cover up for the absence of sentinel character at the end of input,
<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> is redefined to perform a bounds check before it reads the next input character.
This is inefficient, because checks are done very often.
If the check succeeds, <code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> returns the real character,
otherwise it returns a fake sentinel character.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="c1">// expect a string without terminating null</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">lim</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">loop</span><span class="p">:</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:eof = 0;</span>
<span class="cm">    re2c:flags:input = custom;</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE    = char;</span>
<span class="cm">    re2c:define:YYLESSTHAN = &quot;cur &gt;= lim&quot;;</span>
<span class="cm">    re2c:define:YYPEEK     = &quot;cur &lt; lim ? *cur : 0&quot;;  // fake null</span>
<span class="cm">    re2c:define:YYSKIP     = &quot;++cur;&quot;;</span>
<span class="cm">    re2c:define:YYBACKUP   = &quot;mar = cur;&quot;;</span>
<span class="cm">    re2c:define:YYRESTORE  = &quot;cur = mar;&quot;;</span>

<span class="cm">    *                           { return -1; }</span>
<span class="cm">    $                           { return count; }</span>
<span class="cm">    [&#39;] ([^&#39;\\] | [\\][^])* [&#39;] { ++count; goto loop; }</span>
<span class="cm">    [ ]+                        { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="c1">// make a copy of the string without terminating null</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">lex</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">res</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TEST(s, r) test(s, sizeof(s) - 1, r)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">TEST</span><span class="p">(</span><span class="s">&quot;&#39;unterminated</span><span class="se">\\</span><span class="s">&#39;&quot;</span><span class="p">,</span> <span class="mi">-1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="buffer-refilling">
<h2>Buffer refilling<a class="headerlink" href="#buffer-refilling" title="Permalink to this headline">Â¶</a></h2>
<p>The need for buffering arises when the input cannot be mapped in memory all at
once: either it is too large, or it comes in a streaming fashion (like reading
from a socket). The usual technique in such cases is to allocate a fixed-sized
memory buffer and process input in chunks that fit into the buffer. When the
current chunk is processed, it is moved out and new data is moved in. In
practice it is somewhat more complex, because lexer state consists not of a
single input position, but a set of interrelated posiitons:</p>
<ul class="simple">
<li><p>cursor: the next input character to be read (<code class="docutils literal notranslate"><span class="pre">YYCURSOR</span></code> in default API or
<code class="docutils literal notranslate"><span class="pre">YYSKIP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYPEEK</span></code> in generic API)</p></li>
<li><p>limit: the position after the last available input character (<code class="docutils literal notranslate"><span class="pre">YYLIMIT</span></code> in
default API, implicitly handled by <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN</span></code> in generic API)</p></li>
<li><p>marker: the position of the most recent match, if any (<code class="docutils literal notranslate"><span class="pre">YYMARKER</span></code> in default
API or <code class="docutils literal notranslate"><span class="pre">YYBACKUP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYRESTORE</span></code> in generic API)</p></li>
<li><p>token: the start of the current lexeme (implicit in re2c API, as it is not
needed for the normal lexer operation and can be defined and updated by the
user)</p></li>
<li><p>context marker: the position of the trailing context (<code class="docutils literal notranslate"><span class="pre">YYCTXMARKER</span></code> in
default API or <code class="docutils literal notranslate"><span class="pre">YYBACKUPCTX</span></code>/<code class="docutils literal notranslate"><span class="pre">YYRESTORECTX</span></code> in generic API)</p></li>
<li><p>tag variables: submatch positions (defined with <code class="docutils literal notranslate"><span class="pre">/*!stags:re2c*/</span></code> and
<code class="docutils literal notranslate"><span class="pre">/*!mtags:re2c*/</span></code> directives and
<code class="docutils literal notranslate"><span class="pre">YYSTAGP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYSTAGN</span></code>/<code class="docutils literal notranslate"><span class="pre">YYMTAGP</span></code>/<code class="docutils literal notranslate"><span class="pre">YYMTAGN</span></code> in generic API)</p></li>
</ul>
<p>Not all these are used in every case, but if used, they must be updated by
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>. All active positions are contained in the segment between token and
cursor, therefore everything between buffer start and token can be discarded,
the segment from token and up to limit should be moved to the beginning of
buffer, and the free space at the end of buffer should be filled with new data.
In order to avoid frequent <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> calls it is best to fill in as many input
characters as possible (even though fewer characters might suffice to resume the
lexer). The details of <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> implementation are slightly different
depending on which EOF handling method is used: the case of EOF rule is somewhat
simpler than the case of bounds-checking with padding. Also note that if
<code class="docutils literal notranslate"><span class="pre">-f</span> <span class="pre">--storable-state</span></code> option is used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> has slightly different
semantics (desrbed in the section about storable state).</p>
<div class="section" id="yyfill-with-sentinel-character">
<h3>YYFILL with sentinel character<a class="headerlink" href="#yyfill-with-sentinel-character" title="Permalink to this headline">Â¶</a></h3>
<p>If EOF rule is used, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is a function-like primitive that accepts
no arguments and returns a value which is checked against zero. <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
invocation is triggered by condition <code class="docutils literal notranslate"><span class="pre">YYLIMIT</span> <span class="pre">&lt;=</span> <span class="pre">YYCURSOR</span></code> in default API and
<code class="docutils literal notranslate"><span class="pre">YYLESSTHAN()</span></code> in generic API. A non-zero return value means that <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
has failed. A successful <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> call must supply at least one character and
adjust input positions accordingly. Limit must always be set to one after the
last input position in buffer, and the character at the limit position must be
the sentinel symbol specified by <code class="docutils literal notranslate"><span class="pre">re2c:eof</span></code> configuration. The pictures below
show the relative locations of input positions in buffer before and after
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> call (sentinel symbol is marked with <code class="docutils literal notranslate"><span class="pre">#</span></code>, and the second picture
shows the case when there is not enough input to fill the whole buffer).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>               &lt;-- shift --&gt;
             &gt;-A------------B---------C-------------D#-----------E-&gt;
             buffer       token    marker         limit,
                                                  cursor
&gt;-A------------B---------C-------------D------------E#-&gt;
             buffer,  marker        cursor        limit
             token

               &lt;-- shift --&gt;
             &gt;-A------------B---------C-------------D#--E (EOF)
             buffer       token    marker         limit,
                                                  cursor
&gt;-A------------B---------C-------------D---E#........
             buffer,  marker       cursor limit
             token
</pre></div>
</div>
<p>Here is an example of a program that reads input file <code class="docutils literal notranslate"><span class="pre">input.txt</span></code> in chunks of
4096 bytes and uses EOF rule.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define SIZE 4096</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">,</span> <span class="o">*</span><span class="n">tok</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eof</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Input</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fill</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">free</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">+=</span> <span class="n">fread</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">|=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">&lt;</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:eof = 0;</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE  = char;</span>
<span class="cm">    re2c:define:YYCURSOR = in-&gt;cur;</span>
<span class="cm">    re2c:define:YYMARKER = in-&gt;mar;</span>
<span class="cm">    re2c:define:YYLIMIT  = in-&gt;lim;</span>
<span class="cm">    re2c:define:YYFILL   = &quot;fill(in) == 0&quot;;</span>

<span class="cm">    *                           { return -1; }</span>
<span class="cm">    $                           { return count; }</span>
<span class="cm">    [&#39;] ([^&#39;\\] | [\\][^])* [&#39;] { ++count; goto loop; }</span>
<span class="cm">    [ ]+                        { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;input&quot;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
    <span class="n">Input</span> <span class="n">in</span><span class="p">;</span>

    <span class="c1">// prepare input file: a few times the size of the buffer,</span>
    <span class="c1">// containing strings with zeroes and escaped quotes</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="yyfill-with-padding">
<h3>YYFILL with padding<a class="headerlink" href="#yyfill-with-padding" title="Permalink to this headline">Â¶</a></h3>
<p>In the default case (when EOF rule is not used) <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is a function-like
primitive that accepts a single argument and does not return any value.
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocation is triggered by condition <code class="docutils literal notranslate"><span class="pre">(YYLIMIT</span> <span class="pre">-</span> <span class="pre">YYCURSOR)</span> <span class="pre">&lt;</span> <span class="pre">n</span></code> in
default API and <code class="docutils literal notranslate"><span class="pre">YYLESSTHAN(n)</span></code> in generic API. The argument passed to
<code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is the minimal number of characters that must be supplied. If it
fails to do so, <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> must not return to the lexer (for that reason it is
best implemented as a macro that returns from the calling function on failure).
In case of a successful <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> invocation the limit position must be set
either to one after the last input position in buffer, or to the end of
<code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> padding (in case <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> has successfully read at least <code class="docutils literal notranslate"><span class="pre">n</span></code>
characters, but not enough to fill the entire buffer). The pictures below show
the relative locations of input positions in buffer before and after <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>
invocation (<code class="docutils literal notranslate"><span class="pre">YYMAXFILL</span></code> padding on the second picture is marked with <code class="docutils literal notranslate"><span class="pre">#</span></code>
symbols).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>               &lt;-- shift --&gt;                 &lt;-- need --&gt;
             &gt;-A------------B---------C-----D-------E---F--------G-&gt;
             buffer       token    marker cursor  limit

&gt;-A------------B---------C-----D-------E---F--------G-&gt;
             buffer,  marker cursor               limit
             token

               &lt;-- shift --&gt;                 &lt;-- need --&gt;
             &gt;-A------------B---------C-----D-------E-F        (EOF)
             buffer       token    marker cursor  limit

&gt;-A------------B---------C-----D-------E-F###############
             buffer,  marker cursor                   limit
             token                        &lt;- YYMAXFILL -&gt;
</pre></div>
</div>
<p>Here is an example of a program that reads input file <code class="docutils literal notranslate"><span class="pre">input.txt</span></code> in chunks of
4096 bytes and uses bounds-checking with padding.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/*!max:re2c*/</span>
<span class="cp">#define SIZE 4096</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">SIZE</span> <span class="o">+</span> <span class="n">YYMAXFILL</span><span class="p">],</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">,</span> <span class="o">*</span><span class="n">tok</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">eof</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Input</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fill</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">need</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">free</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="n">need</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">+=</span> <span class="n">fread</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">&lt;</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">YYMAXFILL</span><span class="p">);</span>
        <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">+=</span> <span class="n">YYMAXFILL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE  = char;</span>
<span class="cm">    re2c:define:YYCURSOR = in-&gt;cur;</span>
<span class="cm">    re2c:define:YYMARKER = in-&gt;mar;</span>
<span class="cm">    re2c:define:YYLIMIT  = in-&gt;lim;</span>
<span class="cm">    re2c:define:YYFILL   = &quot;if (fill(in, @@) != 0) return -1;&quot;;</span>

<span class="cm">    *                           { return -1; }</span>
<span class="cm">    [\x00]                      { return (in-&gt;lim - in-&gt;cur == YYMAXFILL - 1) ? count : -1; }</span>
<span class="cm">    [&#39;] ([^&#39;\\] | [\\][^])* [&#39;] { ++count; goto loop; }</span>
<span class="cm">    [ ]+                        { goto loop; }</span>

<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;input&quot;</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;&#39;qu</span><span class="se">\0</span><span class="s">tes&#39; &#39;are&#39; &#39;fine: </span><span class="se">\\</span><span class="s">&#39;&#39; &quot;</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
    <span class="n">Input</span> <span class="n">in</span><span class="p">;</span>

    <span class="c1">// prepare input file: a few times the size of the buffer,</span>
    <span class="c1">// containing strings with zeroes and escaped quotes</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="include-files">
<h2>Include files<a class="headerlink" href="#include-files" title="Permalink to this headline">Â¶</a></h2>
<p>re2c allows one to include other files using directive <code class="docutils literal notranslate"><span class="pre">/*!include:re2c</span> <span class="pre">FILE</span> <span class="pre">*/</span></code>
or <code class="docutils literal notranslate"><span class="pre">!include</span> <span class="pre">FILE</span> <span class="pre">;</span></code>, where <code class="docutils literal notranslate"><span class="pre">FILE</span></code> is a path to the file to be included.
The first form should be used outside of re2c blocks, and the second form allows
one to include a file in the middle of a re2c block. re2c looks for included
files in the directory of the including file and in include locations, which
can be specified with <code class="docutils literal notranslate"><span class="pre">-I</span></code> option.
Include directives in re2c work in the same way as C/C++ <code class="docutils literal notranslate"><span class="pre">#include</span></code>: the contents
of <code class="docutils literal notranslate"><span class="pre">FILE</span></code> are copy-pasted verbatim in place of the directive. Include files
may have further includes of their own. Use <code class="docutils literal notranslate"><span class="pre">--depfile</span></code> option to track build
dependencies of the output file on include files.
re2c provides some predefined include files that can be found in the
<code class="docutils literal notranslate"><span class="pre">include/</span></code> subdirectory of the project. These files contain definitions that
can be useful to other projects (such as Unicode categories) and form something
like a standard library for re2c.
Below is an example of using include directive.</p>
<p>Include file 1 (definitions.h):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">OK</span><span class="p">,</span> <span class="n">FAIL</span> <span class="p">}</span> <span class="n">Result</span><span class="p">;</span>

<span class="cm">/*!re2c</span>
<span class="cm">    number = [1-9][0-9]*;</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>Include file 2 (extra_rules.re.inc):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// floating-point numbers
frac  = [0-9]* &quot;.&quot; [0-9]+ | [0-9]+ &quot;.&quot;;
exp   = &#39;e&#39; [+-]? [0-9]+;
float = frac exp? | [0-9]+ exp;

float { return OK; }
</pre></div>
</div>
<p>Input file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -i</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cm">/*!include:re2c &quot;definitions.h&quot; */</span>

<span class="n">Result</span> <span class="nf">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>

<span class="cm">    number { return OK; }</span>
<span class="cm">    !include &quot;extra_rules.re.inc&quot;;</span>
<span class="cm">    * { return FAIL; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;123&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">OK</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;123.4567&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">OK</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="header-files">
<h2>Header files<a class="headerlink" href="#header-files" title="Permalink to this headline">Â¶</a></h2>
<p>Re2c allows one to generate header file from the input <code class="docutils literal notranslate"><span class="pre">.re</span></code> file using option
<code class="docutils literal notranslate"><span class="pre">-t</span></code>, <code class="docutils literal notranslate"><span class="pre">--type-header</span></code> or configuration <code class="docutils literal notranslate"><span class="pre">re2c:flags:type-header</span></code> and
directives <code class="docutils literal notranslate"><span class="pre">/*!header:re2c:on*/</span></code> and <code class="docutils literal notranslate"><span class="pre">/*!header:re2c:off*/</span></code>. The first directive
marks the beginning of header file, and the second directive marks the end of
it. Everything between these directives is processed by re2c, and the generated
code is written to the file specified by the <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">--type-header</span></code> option (or
<code class="docutils literal notranslate"><span class="pre">stdout</span></code> if this option was not used). Autogenerated header file may be needed
in cases when re2c is used to generate definitions of constants, variables and
structs that must be visible from other translation units.</p>
<p>Here is an example of generating a header file that contains definition of the
lexer state with tag variables (the number variables depends on the regular
grammar and is unknown to the programmer).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -i --type-header src/lexer/lexer.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;src/lexer/lexer.h&quot;</span><span class="c1"> // generated by re2c</span><span class="cp"></span>

<span class="cm">/*!header:re2c:on*/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">;</span>
    <span class="cm">/*!stags:re2c format = &quot;const char *@@{tag}; &quot;; */</span>
<span class="p">}</span> <span class="n">LexerState</span><span class="p">;</span>

<span class="cm">/*!header:re2c:off*/</span>

<span class="kt">int</span> <span class="nf">lex</span><span class="p">(</span><span class="n">LexerState</span> <span class="o">*</span><span class="n">st</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:flags:type-header = &quot;src/lexer/lexer.h&quot;;</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:flags:tags = 1;</span>
<span class="cm">    re2c:define:YYCTYPE  = char;</span>
<span class="cm">    re2c:define:YYCURSOR = &quot;st-&gt;cur&quot;;</span>
<span class="cm">    re2c:define:YYMARKER = &quot;st-&gt;mar&quot;;</span>
<span class="cm">    re2c:tags:expression = &quot;st-&gt;@@{tag}&quot;;</span>

<span class="cm">    [x]{1,4} / [x]{3,5} { return 0; } // ambiguous trailing context</span>
<span class="cm">    *                   { return 1; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LexerState</span> <span class="n">st</span><span class="p">;</span>
    <span class="n">st</span><span class="p">.</span><span class="n">str</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">cur</span> <span class="o">=</span> <span class="s">&quot;xxxxxxxx&quot;</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="p">.</span><span class="n">cur</span> <span class="o">-</span> <span class="n">st</span><span class="p">.</span><span class="n">str</span> <span class="o">==</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The generated header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Generated by re2c */</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">yyt1</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">yyt2</span><span class="p">;</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">yyt3</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">LexerState</span><span class="p">;</span>

</pre></div>
</div>
</div>
<div class="section" id="submatch-extraction">
<h2>Submatch extraction<a class="headerlink" href="#submatch-extraction" title="Permalink to this headline">Â¶</a></h2>
<p>Re2c has two options for submatch extraction.</p>
<p>The first option is <code class="docutils literal notranslate"><span class="pre">-T</span> <span class="pre">--tags</span></code>. With this option one can use standalone tags
of the form <code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> and <code class="docutils literal notranslate"><span class="pre">#mtag</span></code>, where <code class="docutils literal notranslate"><span class="pre">stag</span></code> and <code class="docutils literal notranslate"><span class="pre">mtag</span></code> are arbitrary
used-defined names. Tags can be used anywhere inside of a regular expression;
semantically they are just position markers. Tags of the form <code class="docutils literal notranslate"><span class="pre">&#64;stag</span></code> are
called s-tags: they denote a single submatch value (the last input position
where this tag matched). Tags of the form <code class="docutils literal notranslate"><span class="pre">#mtag</span></code> are called m-tags: they
denote multiple submatch values (the whole history of repetitions of this tag).
All tags should be defined by the user as variables with the corresponding
names. With standalone tags re2c uses leftmost greedy disambiguation: submatch
positions correspond to the leftmost matching path through the regular
expression.</p>
<p>The second option is <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code>: it enables POSIX-compliant
capturing groups. In this mode parentheses in regular expressions denote the
beginning and the end of capturing groups; the whole regular expression is group
number zero. The number of groups for the matching rule is stored in a variable
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code>, and submatch results are stored in <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> array. Both
<code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> and <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code> should be defined by the user, and <code class="docutils literal notranslate"><span class="pre">yypmatch</span></code>
size must be at least <code class="docutils literal notranslate"><span class="pre">[yynmatch</span> <span class="pre">*</span> <span class="pre">2]</span></code>. Re2c provides a directive
<code class="docutils literal notranslate"><span class="pre">/*!maxnmatch:re2c*/</span></code> that defines <code class="docutils literal notranslate"><span class="pre">YYMAXNMATCH</span></code>: a constant  equal to the
maximal value of <code class="docutils literal notranslate"><span class="pre">yynmatch</span></code> among all rules. Note that re2c implements
POSIX-compliant disambiguation: each subexpression matches as long as possible,
and subexpressions that start earlier in regular expression have priority over
those starting later. Capturing groups are translated into s-tags under the
hood, therefore we use the word âtagâ to describe them as well.</p>
<p>With both <code class="docutils literal notranslate"><span class="pre">-P</span> <span class="pre">--posix-captures</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">--tags</span></code> options re2c uses efficient
submatch extraction algorithm described in the
<a class="reference external" href="https://arxiv.org/abs/1907.08837">Tagged Deterministic Finite Automata with Lookahead</a>
paper. The overhead on submatch extraction in the generated lexer grows with the
number of tags â if this number is moderate, the overhead is barely
noticeable. In the lexer tags are implemented using a number of tag variables
generated by re2c. There is no one-to-one correspondence between tag variables
and tags: a single variable may be reused for different tags, and one tag may
require multiple variables to hold all its ambiguous values. Eventually
ambiguity is resolved, and only one final variable per tag survives. When a rule
matches, all its tags are set to the values of the corresponding tag variables.
The exact number of tag variables is unknown to the user; this number is
determined by re2c. However, tag variables should be defined by the user as a
part of the lexer state and updated by <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>, therefore re2c provides
directives <code class="docutils literal notranslate"><span class="pre">/*!stags:re2c*/</span></code> and <code class="docutils literal notranslate"><span class="pre">/*!mtags:re2c*/</span></code> that can be used to
declare, initialize and manipulate tag variables. These directives have two
optional configurations: <code class="docutils literal notranslate"><span class="pre">format</span> <span class="pre">=</span> <span class="pre">&quot;&#64;&#64;&quot;;</span></code> (specifies the template where <code class="docutils literal notranslate"><span class="pre">&#64;&#64;</span></code>
is substituted with the name of each tag variable), and <code class="docutils literal notranslate"><span class="pre">separator</span> <span class="pre">=</span> <span class="pre">&quot;&quot;;</span></code>
(specifies the piece of code used to join the generated pieces for different
tag variables).</p>
<p>S-tags support the following operations:</p>
<ul class="simple">
<li><p>save input position to an s-tag: <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">YYCURSOR</span></code> with default API or a
user-defined operation <code class="docutils literal notranslate"><span class="pre">YYSTAGP(t)</span></code> with generic API</p></li>
<li><p>save default value to an s-tag: <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">NULL</span></code> with default API or a
user-defined operation <code class="docutils literal notranslate"><span class="pre">YYSTAGN(t)</span></code> with generic API</p></li>
<li><p>copy one s-tag to another: <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">t2</span></code></p></li>
</ul>
<p>M-tags support the following operations:</p>
<ul class="simple">
<li><p>append input position to an m-tag: a user-defined operation <code class="docutils literal notranslate"><span class="pre">YYMTAGP(t)</span></code>
with both default and generic API</p></li>
<li><p>append default value to an m-tag: a user-defined operation <code class="docutils literal notranslate"><span class="pre">YYMTAGN(t)</span></code>
with both default and generic API</p></li>
<li><p>copy one m-tag to another: <code class="docutils literal notranslate"><span class="pre">t1</span> <span class="pre">=</span> <span class="pre">t2</span></code></p></li>
</ul>
<p>S-tags can be implemented as scalar values (pointers or offsets). M-tags need a
more complex representation, as they need to store a sequence of tag values. The
most naive and inefficient representation of an m-tag is a list (array, vector)
of tag values; a more efficient representation is to store all m-tags in a
prefix-tree represented as array of nodes <code class="docutils literal notranslate"><span class="pre">(v,</span> <span class="pre">p)</span></code>, where <code class="docutils literal notranslate"><span class="pre">v</span></code> is tag value
and <code class="docutils literal notranslate"><span class="pre">p</span></code> is a pointer to parent node.</p>
<p>Here is a simple example of using s-tags to parse an IPv4 address
(see below for a more complex example that uses <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code>).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">num</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ERROR</span> <span class="o">=</span> <span class="o">~</span><span class="mf">0l</span><span class="n">u</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">,</span> <span class="o">*</span><span class="n">o1</span><span class="p">,</span> <span class="o">*</span><span class="n">o2</span><span class="p">,</span> <span class="o">*</span><span class="n">o3</span><span class="p">,</span> <span class="o">*</span><span class="n">o4</span><span class="p">;</span>
    <span class="cm">/*!stags:re2c format = &#39;const char *@@;&#39;; */</span>

    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:flags:tags = 1;</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>

<span class="cm">    octet = [0-9] | [1-9][0-9] | [1][0-9][0-9] | [2][0-4][0-9] | [2][5][0-5];</span>
<span class="cm">    dot = [.];</span>
<span class="cm">    end = [\x00];</span>

<span class="cm">    @o1 octet dot @o2 octet dot @o3 octet dot @o4 octet end {</span>
<span class="cm">        return num(o4, YYCURSOR - 1)</span>
<span class="cm">            + (num(o3, o4 - 1) &lt;&lt; 8)</span>
<span class="cm">            + (num(o2, o3 - 1) &lt;&lt; 16)</span>
<span class="cm">            + (num(o1, o2 - 1) &lt;&lt; 24);</span>
<span class="cm">    }</span>
<span class="cm">    * { return ERROR; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.4&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01020304</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x7f000001</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;255.255.255.255&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.256&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is a more complex example of using s-tags with <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> to parse a file
with IPv4 addresses. Tag variables are part of the lexer state, and they are
adjusted in <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> like other input positions.
Note that it is necessary for s-tags because their values are invalidated after
shifting buffer contents. It may not be necessary in a custom implementation
where tag variables store offsets relative to the start of the input string
rather than buffer, which may be the case with m-tags.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT --tags</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#define SIZE 4096</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">,</span> <span class="o">*</span><span class="n">tok</span><span class="p">;</span>
    <span class="c1">// Tag variables must be part of the lexer state passed to YYFILL.</span>
    <span class="c1">// They don&#39;t correspond to tags and should be autogenerated by re2c.</span>
    <span class="cm">/*!stags:re2c format = &#39;const char *@@;&#39;; */</span>
    <span class="kt">int</span> <span class="n">eof</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Input</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">fill</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">free</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">memmove</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">);</span>

    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-=</span> <span class="n">free</span><span class="p">;</span>
    <span class="c1">// Tag variables need to be shifted like other input positions. The check</span>
    <span class="c1">// for non-NULL is only needed if some tags are nested inside of alternative</span>
    <span class="c1">// or repetition, so that they can have NULL value.</span>
    <span class="cm">/*!stags:re2c format = &quot;if (in-&gt;@@) in-&gt;@@ -= free;&quot;; */</span>

    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">+=</span> <span class="n">fread</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">|=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">&lt;</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">SIZE</span><span class="p">;</span>
    <span class="c1">// Initialization is only needed to avoid &quot;use of uninitialized&quot; warnings</span>
    <span class="c1">// when shifting tags in YYFILL. In the lexer tags are guaranteed to be</span>
    <span class="c1">// set before they are used (either to a valid input position, or NULL).</span>
    <span class="cm">/*!stags:re2c format = &quot;in-&gt;@@ = in-&gt;lim;&quot;; */</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fill</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">num</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="n">lex</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ips</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// User-defined local variables that store final tag values.</span>
    <span class="c1">// They are different from tag variables autogenerated with /*!stags:re2c*/,</span>
    <span class="c1">// as they are set at the end of match and used only in semantic actions.</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">o1</span><span class="p">,</span> <span class="o">*</span><span class="n">o2</span><span class="p">,</span> <span class="o">*</span><span class="n">o3</span><span class="p">,</span> <span class="o">*</span><span class="n">o4</span><span class="p">;</span>
<span class="nl">loop</span><span class="p">:</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:eof = 0;</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE  = char;</span>
<span class="cm">    re2c:define:YYCURSOR = in-&gt;cur;</span>
<span class="cm">    re2c:define:YYMARKER = in-&gt;mar;</span>
<span class="cm">    re2c:define:YYLIMIT  = in-&gt;lim;</span>
<span class="cm">    re2c:define:YYFILL   = &quot;fill(in) == 0&quot;;</span>

<span class="cm">    // The way tag variables are accessed from the lexer (not needed if tag</span>
<span class="cm">    // variables are defined as local variables).</span>
<span class="cm">    re2c:tags:expression = &quot;in-&gt;@@&quot;;</span>

<span class="cm">    octet = [0-9] | [1-9][0-9] | [1][0-9][0-9] | [2][0-4][0-9] | [2][5][0-5];</span>
<span class="cm">    dot = [.];</span>
<span class="cm">    eol = [\n];</span>

<span class="cm">    @o1 octet dot @o2 octet dot @o3 octet dot @o4 octet eol {</span>
<span class="cm">        ips.push_back(num(o4, in-&gt;cur - 1)</span>
<span class="cm">            + (num(o3, o4 - 1) &lt;&lt; 8)</span>
<span class="cm">            + (num(o2, o3 - 1) &lt;&lt; 16)</span>
<span class="cm">            + (num(o1, o2 - 1) &lt;&lt; 24));</span>
<span class="cm">        goto loop;</span>
<span class="cm">    }</span>
<span class="cm">    $ { return true; }</span>
<span class="cm">    * { return false; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;input&quot;</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
    <span class="n">Input</span> <span class="n">in</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">have</span><span class="p">,</span> <span class="n">want</span><span class="p">;</span>

    <span class="c1">// Write a few IPv4 addresses to the input file and save them to compare</span>
    <span class="c1">// against parse results.</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%d.%d.%d.%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">want</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">have</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">have</span> <span class="o">==</span> <span class="n">want</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is an example of using POSIX capturing groups to parse an IPv4 address.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">num</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">s</span><span class="p">)</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*!maxnmatch:re2c*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ERROR</span> <span class="o">=</span> <span class="o">~</span><span class="mf">0l</span><span class="n">u</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">yypmatch</span><span class="p">[</span><span class="n">YYMAXNMATCH</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">yynmatch</span><span class="p">;</span>
    <span class="cm">/*!stags:re2c format = &#39;const char *@@;&#39;; */</span>

    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:flags:posix-captures = 1;</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>

<span class="cm">    octet = [0-9] | [1-9][0-9] | [1][0-9][0-9] | [2][0-4][0-9] | [2][5][0-5];</span>
<span class="cm">    dot = [.];</span>
<span class="cm">    end = [\x00];</span>

<span class="cm">    (octet) dot (octet) dot (octet) dot (octet) end {</span>
<span class="cm">        assert(yynmatch == 5);</span>
<span class="cm">        return num(yypmatch[8], yypmatch[9])</span>
<span class="cm">            + (num(yypmatch[6], yypmatch[7]) &lt;&lt; 8)</span>
<span class="cm">            + (num(yypmatch[4], yypmatch[5]) &lt;&lt; 16)</span>
<span class="cm">            + (num(yypmatch[2], yypmatch[3]) &lt;&lt; 24);</span>
<span class="cm">    }</span>
<span class="cm">    * { return ERROR; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.4&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x01020304</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;127.0.0.1&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x7f000001</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;255.255.255.255&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;1.2.3.256&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here is an example of using m-tags to parse a semicolon-separated sequence of
words (C++). Tag variables are stored in a tree that is packed in a vector.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT </span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ROOT</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">Mtag</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pred</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tag</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mtag</span><span class="o">&gt;</span> <span class="n">MtagTree</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Words</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">mtag</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">MtagTree</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Mtag</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">pt</span><span class="p">,</span> <span class="n">t</span><span class="p">};</span>
    <span class="o">*</span><span class="n">pt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
    <span class="n">tree</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">unfold</span><span class="p">(</span><span class="k">const</span> <span class="n">MtagTree</span> <span class="o">&amp;</span><span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Words</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">ROOT</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">unfold</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">pred</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">pred</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">px</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">tag</span><span class="p">,</span> <span class="o">*</span><span class="n">py</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">y</span><span class="p">].</span><span class="n">tag</span><span class="p">;</span>
    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">-</span> <span class="n">px</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define YYMTAGP(t) mtag(&amp;t, YYCURSOR, &amp;tree)</span>
<span class="cp">#define YYMTAGN(t) mtag(&amp;t, NULL,     &amp;tree)</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">,</span> <span class="n">Words</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="cm">/*!mtags:re2c format = &quot;int @@ = ROOT;&quot;; */</span>
    <span class="n">MtagTree</span> <span class="n">tree</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>

    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:flags:tags = 1;</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>

<span class="cm">    (#x [a-z]+ #y [;])+ {</span>
<span class="cm">        words.clear();</span>
<span class="cm">        unfold(tree, x, y, words);</span>
<span class="cm">        return true;</span>
<span class="cm">    }</span>
<span class="cm">    * { return false; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Words</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;one;two;three;&quot;</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">==</span> <span class="n">Words</span><span class="p">({</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">}));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="storable-state">
<h2>Storable state<a class="headerlink" href="#storable-state" title="Permalink to this headline">Â¶</a></h2>
<p>With <code class="docutils literal notranslate"><span class="pre">-f</span></code> <code class="docutils literal notranslate"><span class="pre">--storable-state</span></code> option re2c generates a lexer that can store
its current state, return to the caller, and later resume operations exactly
where it left off. The default mode of operation in re2c is a âpullâ model,
in which the lexer âpullsâ more input whenever it needs it. This may be
unacceptable in cases when the input becomes available piece by piece (for
example, if the lexer is invoked by the parser, or if the lexer program
communicates via a socket protocol with some other program that must wait for a
reply from the lexer before it transmits the next message). Storable state
feature is intended exactly for such cases: it allows one to generate lexers that
work in a âpushâ model. When the lexer needs more input, it stores its state and
returns to the caller. Later, when more input becomes available, the caller
resumes the lexer exactly where it stopped. There are a few changes necessary
compared to the âpullâ model:</p>
<ul class="simple">
<li><p>Define <code class="docutils literal notranslate"><span class="pre">YYSETSTATE()</span></code> and <code class="docutils literal notranslate"><span class="pre">YYGETSTATE(state)</span></code> promitives.</p></li>
<li><p>Define <code class="docutils literal notranslate"><span class="pre">yych</span></code>, <code class="docutils literal notranslate"><span class="pre">yyaccept</span></code> and <code class="docutils literal notranslate"><span class="pre">state</span></code> variables as a part of persistent
lexer state. The <code class="docutils literal notranslate"><span class="pre">state</span></code> variable should be initialized to <code class="docutils literal notranslate"><span class="pre">-1</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> should return to the outer program instead of trying to supply more
input. Return code should indicate that lexer needs more input.</p></li>
<li><p>The outer program should recognize situations when lexer needs more input and
respond appropriately.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">/*!getstate:re2c*/</span></code> directive if it is necessary to execute any code
before entering the lexer.</p></li>
<li><p>Use configurations <code class="docutils literal notranslate"><span class="pre">state:abort</span></code> and <code class="docutils literal notranslate"><span class="pre">state:nextlabel</span></code> to further tweak
the generated code.</p></li>
</ul>
<p>Here is an example of a âpushâ-model lexer that reads input from <code class="docutils literal notranslate"><span class="pre">stdin</span></code> and
expects a sequence of words separated by spaces and newlines. The lexer loops
forever, waiting for more input. It can be terminated by sending a special EOF
token â a word âstopâ, in which case the lexer terminates successfully and
prints the number of words it has seen. Abnormal termination happens in case of
a syntax error, premature end of input (without the âstopâ word) or in case the
buffer is too small to hold a lexeme (for example, if one of the words exceeds
buffer size). Premature end of input happens in case the lexer fails to read any
input while being in the initial state â this is the only case when EOF rule
matches. Note that the lexer may call <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> twice before terminating (and
thus require hitting <code class="docutils literal notranslate"><span class="pre">Ctrl+D</span></code> a few times). First time <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> is called
when the lexer expects continuation of the current greedy lexeme (either a word
or a whitespace sequence). If <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> fails, the lexer knows that it has
reached the end of the current lexeme and executes the corresponding semantic
action. The action jumps to the beginning of the loop, the lexer enters the
initial state and calls <code class="docutils literal notranslate"><span class="pre">YYFILL</span></code> once more. If it fails, the lexer matches EOF
rule. (Alternatively EOF rule can be used for termination instead of a special
EOF lexeme.)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -f</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define DEBUG    0</span>
<span class="cp">#define LOG(...) if (DEBUG) fprintf(stderr, __VA_ARGS__);</span>
<span class="cp">#define BUFSIZE  10</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFSIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">lim</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span> <span class="o">*</span><span class="n">mar</span><span class="p">,</span> <span class="o">*</span><span class="n">tok</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">yyaccept</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Input</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">init</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">+</span> <span class="n">BUFSIZE</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// append sentinel symbol</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">yyaccept</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">END</span><span class="p">,</span> <span class="n">READY</span><span class="p">,</span> <span class="n">WAITING</span><span class="p">,</span> <span class="n">BAD_PACKET</span><span class="p">,</span> <span class="n">BIG_PACKET</span><span class="p">}</span> <span class="n">Status</span><span class="p">;</span>

<span class="k">static</span> <span class="n">Status</span> <span class="n">fill</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">free</span> <span class="o">=</span> <span class="n">BUFSIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">free</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">BIG_PACKET</span><span class="p">;</span>

    <span class="n">memmove</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span><span class="p">,</span> <span class="n">BUFSIZE</span> <span class="o">-</span> <span class="n">shift</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">mar</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">-=</span> <span class="n">shift</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">read</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">);</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span> <span class="o">+=</span> <span class="n">read</span><span class="p">;</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">lim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// append sentinel symbol</span>

    <span class="k">return</span> <span class="n">READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Status</span> <span class="n">lex</span><span class="p">(</span><span class="n">Input</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">recv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">yych</span><span class="p">;</span>
    <span class="cm">/*!getstate:re2c*/</span>
<span class="nl">loop</span><span class="p">:</span>
    <span class="n">in</span><span class="o">-&gt;</span><span class="n">tok</span> <span class="o">=</span> <span class="n">in</span><span class="o">-&gt;</span><span class="n">cur</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">        re2c:eof = 0;</span>
<span class="cm">        re2c:api:style = free-form;</span>
<span class="cm">        re2c:define:YYCTYPE    = &quot;char&quot;;</span>
<span class="cm">        re2c:define:YYCURSOR   = &quot;in-&gt;cur&quot;;</span>
<span class="cm">        re2c:define:YYMARKER   = &quot;in-&gt;mar&quot;;</span>
<span class="cm">        re2c:define:YYLIMIT    = &quot;in-&gt;lim&quot;;</span>
<span class="cm">        re2c:define:YYGETSTATE = &quot;in-&gt;state&quot;;</span>
<span class="cm">        re2c:define:YYSETSTATE = &quot;in-&gt;state = @@;&quot;;</span>
<span class="cm">        re2c:define:YYFILL     = &quot;return WAITING;&quot;;</span>

<span class="cm">        packet = [a-z]+[;];</span>

<span class="cm">        *      { return BAD_PACKET; }</span>
<span class="cm">        $      { return END; }</span>
<span class="cm">        packet { *recv = *recv + 1; goto loop; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">packets</span><span class="p">,</span> <span class="n">Status</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span> <span class="o">=</span> <span class="s">&quot;pipe&quot;</span><span class="p">;</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fw</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fr</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">setvbuf</span><span class="p">(</span><span class="n">fr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">_IONBF</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="n">Input</span> <span class="n">in</span><span class="p">;</span>
    <span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">fr</span><span class="p">);</span>
    <span class="n">Status</span> <span class="n">st</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">send</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">recv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">lex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">END</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;done: got %u packets</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">recv</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">WAITING</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;waiting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">packets</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;sent packet %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">send</span><span class="p">);</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">packets</span><span class="o">++</span><span class="p">);</span>
                <span class="o">++</span><span class="n">send</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
            <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;queue: &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">in</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">BIG_PACKET</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;error: packet too big</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">READY</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">BAD_PACKET</span><span class="p">);</span>
            <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;error: ill-formed packet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">LOG</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">status</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st</span> <span class="o">==</span> <span class="n">END</span><span class="p">)</span> <span class="n">assert</span><span class="p">(</span><span class="n">recv</span> <span class="o">==</span> <span class="n">send</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">fw</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fr</span><span class="p">);</span>
    <span class="n">remove</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packets1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packets2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;zero;&quot;</span><span class="p">,</span> <span class="s">&quot;one;&quot;</span><span class="p">,</span> <span class="s">&quot;two;&quot;</span><span class="p">,</span> <span class="s">&quot;three;&quot;</span><span class="p">,</span> <span class="s">&quot;four;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packets3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;zer0;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">packets4</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;goooooooooogle;&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

    <span class="n">test</span><span class="p">(</span><span class="n">packets1</span><span class="p">,</span> <span class="n">END</span><span class="p">);</span>
    <span class="n">test</span><span class="p">(</span><span class="n">packets2</span><span class="p">,</span> <span class="n">END</span><span class="p">);</span>
    <span class="n">test</span><span class="p">(</span><span class="n">packets3</span><span class="p">,</span> <span class="n">BAD_PACKET</span><span class="p">);</span>
    <span class="n">test</span><span class="p">(</span><span class="n">packets4</span><span class="p">,</span> <span class="n">BIG_PACKET</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reusable-blocks">
<h2>Reusable blocks<a class="headerlink" href="#reusable-blocks" title="Permalink to this headline">Â¶</a></h2>
<p>Reuse mode is enabled with the <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code> option. In this mode re2c
allows one to reuse definitions, configurations and rules specified by a
<code class="docutils literal notranslate"><span class="pre">/*!rules:re2c*/</span></code> block in subsequent <code class="docutils literal notranslate"><span class="pre">/*!use:re2c*/</span></code> blocks. As of
re2c-1.2 it is possible to mix such blocks with normal <code class="docutils literal notranslate"><span class="pre">/*!re2c*/</span></code> blocks;
prior to that re2c expects a single rules-block followed by use-blocks (normal
blocks are disallowed). Use-blocks can have additional definitions,
configurations and rules: they are merged to those specified by the rules-block.
A very common use case for <code class="docutils literal notranslate"><span class="pre">-r</span> <span class="pre">--reusable</span></code> option is a lexer that supports
multiple input encodings: lexer rules are defined once and reused multiple times
with encoding-specific configurations, such as <code class="docutils literal notranslate"><span class="pre">re2c:flags:utf-8</span></code>.</p>
<p>Below is an example of a multi-encoding lexer: it reads a phrase with Unicode
math symbols and accepts input either in UTF8 or in UT32. Note that the
<code class="docutils literal notranslate"><span class="pre">--input-encoding</span> <span class="pre">utf8</span></code> option allows us to write UTF8-encoded symbols in the
regular expressions; without this option re2c would parse them as a plain ASCII
byte sequnce (and we would have to use hexadecimal escape sequences).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -r --input-encoding utf8</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="cm">/*!rules:re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>

<span class="cm">    &quot;âx ây: p(x, y)&quot; { return 0; }</span>
<span class="cm">    *                { return 1; }</span>
<span class="cm">*/</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lex_utf8</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="cm">/*!use:re2c</span>
<span class="cm">    re2c:define:YYCTYPE = uint8_t;</span>
<span class="cm">    re2c:flags:8 = 1;</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lex_utf32</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="cm">/*!use:re2c</span>
<span class="cm">    re2c:define:YYCTYPE = uint32_t;</span>
<span class="cm">    re2c:flags:8 = 0;</span>
<span class="cm">    re2c:flags:u = 1;</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">s8</span><span class="p">[]</span> <span class="o">=</span> <span class="c1">// UTF-8</span>
        <span class="p">{</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xe2</span><span class="p">,</span> <span class="mh">0x88</span><span class="p">,</span> <span class="mh">0x83</span><span class="p">,</span> <span class="mh">0x79</span>
        <span class="p">,</span> <span class="mh">0x3a</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x70</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">,</span> <span class="mh">0x2c</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x79</span><span class="p">,</span> <span class="mh">0x29</span> <span class="p">};</span>

    <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">s32</span><span class="p">[]</span> <span class="o">=</span> <span class="c1">// UTF32</span>
        <span class="p">{</span> <span class="mh">0x00002200</span><span class="p">,</span> <span class="mh">0x00000078</span><span class="p">,</span> <span class="mh">0x00000020</span><span class="p">,</span> <span class="mh">0x00002203</span>
        <span class="p">,</span> <span class="mh">0x00000079</span><span class="p">,</span> <span class="mh">0x0000003a</span><span class="p">,</span> <span class="mh">0x00000020</span><span class="p">,</span> <span class="mh">0x00000070</span>
        <span class="p">,</span> <span class="mh">0x00000028</span><span class="p">,</span> <span class="mh">0x00000078</span><span class="p">,</span> <span class="mh">0x0000002c</span><span class="p">,</span> <span class="mh">0x00000020</span>
        <span class="p">,</span> <span class="mh">0x00000079</span><span class="p">,</span> <span class="mh">0x00000029</span> <span class="p">};</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">lex_utf8</span><span class="p">(</span><span class="n">s8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex_utf32</span><span class="p">(</span><span class="n">s32</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
</div>
<div class="section" id="encoding-support">
<h2>Encoding support<a class="headerlink" href="#encoding-support" title="Permalink to this headline">Â¶</a></h2>
<p>Speaking of encodings, it is necessary to understand the difference between code points and code units.
Code point is an abstract symbol.
Code unit is the smallest atomic unit of storage in the encoded text.
A single code point may be represented with one or more code units.
In a fixed-length encoding all code points are represented with the same number of code units.
In a variable-length encoding code points may be represented with a different number of code units.
Note that the âanyâ rule <code class="docutils literal notranslate"><span class="pre">[^]</span></code> matches any code point, but not necessarily any code unit.
The only way to match any code unit regardless of the encoding it the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>.
<code class="docutils literal notranslate"><span class="pre">YYCTYPE</span></code> size should be equal to the size of code unit.</p>
<p>Re2c supports the following encodings: ASCII, EBCDIC, UCS2, UTF8, UTF16 and UTF32.</p>
<ul class="simple">
<li><p>ASCII is enabled by default.
It is a fixed-length encoding with code space [0-255] and 1-byte code points
and code units.</p></li>
<li><p>EBCDIC is enabled with <code class="docutils literal notranslate"><span class="pre">-e,</span> <span class="pre">--ecb</span></code> option.
It a fixed-length encoding with code space [0-255] and 1-byte code points
and code units.</p></li>
<li><p>UCS2 is enabled with <code class="docutils literal notranslate"><span class="pre">-w,</span> <span class="pre">--wide-chars</span></code> option.
It is a fixed-length encoding with code space [0-0xFFFF] and 2-byte code
points and code units.</p></li>
<li><p>UTF8 is enabled with <code class="docutils literal notranslate"><span class="pre">-8,</span> <span class="pre">--utf-8</span></code> option.
It is a variable-length Unicode encoding with code space [0-0x10FFFF].
Code points are represented with one, two, three or four 1-byte code units.</p></li>
<li><p>UTF16 is enabled with <code class="docutils literal notranslate"><span class="pre">-x,</span> <span class="pre">--utf-16</span></code> option.
It is a variable-length Unicode encoding with code space [0-0x10FFFF].
Code points are represented with one or two 2-byte code units.</p></li>
<li><p>UTF32 is enabled with <code class="docutils literal notranslate"><span class="pre">-u,</span> <span class="pre">--unicode</span></code> option.
It is a fixed-length Unicode encoding with code space [0-0x10FFFF] and 4-byte
code points and code units.</p></li>
</ul>
<p>Encodings can also be set or unset using <code class="docutils literal notranslate"><span class="pre">re2c:flags</span></code> configuration,
for example <code class="docutils literal notranslate"><span class="pre">re2c:flags:8</span> <span class="pre">=</span> <span class="pre">1;</span></code> enables UTF8.</p>
<p>Include file <code class="docutils literal notranslate"><span class="pre">include/unicode_categories.re</span></code> provides re2c definitions for the standard Unicode categories.</p>
<p>Option <code class="docutils literal notranslate"><span class="pre">--input-encoding</span> <span class="pre">utf8</span></code> enables Unicode literals in regular expressions.</p>
<p>Option <code class="docutils literal notranslate"><span class="pre">--encoding-policy</span> <span class="pre">&lt;fail</span> <span class="pre">|</span> <span class="pre">substitute</span> <span class="pre">|</span> <span class="pre">ignore&gt;</span></code>
specifies the way re2c handles Unicode surrogates: code points in the range [0xD800-0xDFFF].</p>
<p>Here is an example of a lexer for Unicode identifiers encoded in UTF8.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -8 --case-ranges -i</span>
<span class="c1">//</span>
<span class="c1">// Simplified &quot;Unicode Identifier and Pattern Syntax&quot;</span>
<span class="c1">// (see https://unicode.org/reports/tr31)</span>

<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="cm">/*!include:re2c &quot;unicode_categories.re&quot; */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:define:YYCTYPE = &#39;unsigned char&#39;;</span>
<span class="cm">    re2c:yyfill:enable  = 0;</span>

<span class="cm">    id_start    = L | Nl | [$_];</span>
<span class="cm">    id_continue = id_start | Mn | Mc | Nd | Pc | [\u200D\u05F3];</span>
<span class="cm">    identifier  = id_start id_continue*;</span>

<span class="cm">    identifier { return 0; }</span>
<span class="cm">    *          { return 1; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">lex</span><span class="p">(</span><span class="s">&quot;_Ð«Ð´ÐµÐ½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¾Ñ&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="start-conditions">
<h2>Start conditions<a class="headerlink" href="#start-conditions" title="Permalink to this headline">Â¶</a></h2>
<p>Conditions are enabled with <code class="docutils literal notranslate"><span class="pre">-c</span></code> <code class="docutils literal notranslate"><span class="pre">--conditions</span></code>.
This option allows one to encode multiple interrelated lexers within the same re2c block.</p>
<p>Each lexer corresponds to a single condition.
It starts with a label of the form <code class="docutils literal notranslate"><span class="pre">yyc_name</span></code>,
where <code class="docutils literal notranslate"><span class="pre">name</span></code> is condition name
and <code class="docutils literal notranslate"><span class="pre">yyc</span></code> prefix can be adjusted with configuration <code class="docutils literal notranslate"><span class="pre">re2c:condprefix</span></code>.
Different lexers are separated with a comment <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">***********************************</span> <span class="pre">*/</span></code>
which can be adjusted with configuration <code class="docutils literal notranslate"><span class="pre">re2c:cond:divider</span></code>.</p>
<p>Furthermore, each condition has a unique identifier of the form <code class="docutils literal notranslate"><span class="pre">yycname</span></code>,
where <code class="docutils literal notranslate"><span class="pre">name</span></code> is condition name
and <code class="docutils literal notranslate"><span class="pre">yyc</span></code> prefix can be adjusted with configuration <code class="docutils literal notranslate"><span class="pre">re2c:condenumprefix</span></code>.
Identifiers have the type <code class="docutils literal notranslate"><span class="pre">YYCONDTYPE</span></code> and should be generated with <code class="docutils literal notranslate"><span class="pre">/*!types:re2c*/</span></code> directive or <code class="docutils literal notranslate"><span class="pre">-t</span></code> <code class="docutils literal notranslate"><span class="pre">--type-header</span></code> option.
Users shouldnât define these identifiers manually, as the order of conditions is not specified.</p>
<p>Before all conditions re2c generates entry code that checks the current condition identifier
and transfers control flow to the start label of the active condition.
After matching some rule of this condition,
lexer may either transfer control flow back to the entry code (after executing the associated action and optionally setting another condition with <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>),
or use <code class="docutils literal notranslate"><span class="pre">:=&gt;</span></code> shortcut and transition directly to the start label of another condition (skipping the action and the entry code).
Configuration <code class="docutils literal notranslate"><span class="pre">re2c:cond:goto</span></code> allows one to change the default behavior.</p>
<p>Syntactically each rule must be preceded with a list of comma-separated condition names or a wildcard <code class="docutils literal notranslate"><span class="pre">*</span></code>
enclosed in angle brackets <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>.
Wildcard means âany conditionâ and is semantically equivalent to listing all condition names.
Here <code class="docutils literal notranslate"><span class="pre">regexp</span></code> is a regular expression, <code class="docutils literal notranslate"><span class="pre">default</span></code> refers to the default rule <code class="docutils literal notranslate"><span class="pre">*</span></code>,
and <code class="docutils literal notranslate"><span class="pre">action</span></code> is a block of code.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;conditions-or-wildcard&gt;</span>&#160; <span class="pre">regexp-or-default</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">action</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;conditions-or-wildcard&gt;</span>&#160; <span class="pre">regexp-or-default</span>&#160; <span class="pre">=&gt;</span>&#160; <span class="pre">condition</span>&#160; <span class="pre">action</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;conditions-or-wildcard&gt;</span>&#160; <span class="pre">regexp-or-default</span>&#160; <span class="pre">:=&gt;</span> <span class="pre">condition</span></code></p></li>
</ul>
<p>Rules with an exclamation mark <code class="docutils literal notranslate"><span class="pre">!</span></code> in front of condition list have a special meaning:
they have no regular expression,
and the associated action is merged as an entry code to actions of normal rules.
This might be a convenient place to peform a routine task that is common to all rules.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;!conditions-or-wildcard&gt;</span>&#160; <span class="pre">action</span></code></p></li>
</ul>
<p>Another special form of rules with an empty condition list <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> and no regular expression
allows one to specify an âentry conditionâ that can be used to execute code before entering the lexer.
It is semantically equivalent to a condition with number zero, name <code class="docutils literal notranslate"><span class="pre">0</span></code> and an empty regular expression.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">action</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span>&#160; <span class="pre">=&gt;</span>&#160; <span class="pre">condition</span>&#160; <span class="pre">action</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span>&#160; <span class="pre">:=&gt;</span> <span class="pre">condition</span></code></p></li>
</ul>
<p>Here is an example program that uses start conditions to parse integer numbers in binary, octal, decimal and hexadecimal format:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// re2c $INPUT -o $OUTPUT -ci</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">ERROR</span> <span class="o">=</span> <span class="o">~</span><span class="mf">0l</span><span class="n">u</span><span class="p">;</span>
<span class="cm">/*!types:re2c*/</span>

<span class="n">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">BASE</span><span class="o">&gt;</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">adddgt</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">&amp;</span><span class="n">u</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">BASE</span> <span class="o">+</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;</span> <span class="n">UINT32_MAX</span><span class="p">)</span> <span class="n">u</span> <span class="o">=</span> <span class="n">ERROR</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">uint64_t</span> <span class="n">parse_u32</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYMARKER</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">yycinit</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*!re2c</span>
<span class="cm">    re2c:yyfill:enable = 0;</span>
<span class="cm">    re2c:api:style = free-form;</span>
<span class="cm">    re2c:define:YYCTYPE = char;</span>
<span class="cm">    re2c:define:YYCURSOR = s;</span>
<span class="cm">    re2c:define:YYGETCONDITION = &quot;c&quot;;</span>
<span class="cm">    re2c:define:YYSETCONDITION = &quot;c = @@;&quot;;</span>

<span class="cm">    &lt;*&gt; * { return ERROR; }</span>

<span class="cm">    &lt;init&gt; &#39;0b&#39; / [01]        :=&gt; bin</span>
<span class="cm">    &lt;init&gt; &quot;0&quot;                :=&gt; oct</span>
<span class="cm">    &lt;init&gt; &quot;&quot; / [1-9]         :=&gt; dec</span>
<span class="cm">    &lt;init&gt; &#39;0x&#39; / [0-9a-fA-F] :=&gt; hex</span>

<span class="cm">    &lt;bin, oct, dec, hex&gt; &quot;\x00&quot; { return u; }</span>

<span class="cm">    &lt;bin&gt; [01]  { adddgt&lt;2&gt; (u, s[-1] - &#39;0&#39;);      goto yyc_bin; }</span>
<span class="cm">    &lt;oct&gt; [0-7] { adddgt&lt;8&gt; (u, s[-1] - &#39;0&#39;);      goto yyc_oct; }</span>
<span class="cm">    &lt;dec&gt; [0-9] { adddgt&lt;10&gt;(u, s[-1] - &#39;0&#39;);      goto yyc_dec; }</span>
<span class="cm">    &lt;hex&gt; [0-9] { adddgt&lt;16&gt;(u, s[-1] - &#39;0&#39;);      goto yyc_hex; }</span>
<span class="cm">    &lt;hex&gt; [a-f] { adddgt&lt;16&gt;(u, s[-1] - &#39;a&#39; + 10); goto yyc_hex; }</span>
<span class="cm">    &lt;hex&gt; [A-F] { adddgt&lt;16&gt;(u, s[-1] - &#39;A&#39; + 10); goto yyc_hex; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;1234567890&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1234567890</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;0b1101&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">13</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;0x7Fe&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2046</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;0644&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">420</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;9999999999&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">parse_u32</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ERROR</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="skeleton-programs">
<h2>Skeleton programs<a class="headerlink" href="#skeleton-programs" title="Permalink to this headline">Â¶</a></h2>
<p>With the <code class="docutils literal notranslate"><span class="pre">-S,</span> <span class="pre">--skeleton</span></code> option, re2c ignores all non-re2c code and generates
a self-contained C program that can be further compiled and executed. The
program consists of lexer code and input data. For each constructed DFA (block
or condition) re2c generates a standalone lexer and two files: an <code class="docutils literal notranslate"><span class="pre">.input</span></code>
file with strings derived from the DFA and a <code class="docutils literal notranslate"><span class="pre">.keys</span></code> file with expected match
results. The program runs each lexer on the corresponding <code class="docutils literal notranslate"><span class="pre">.input</span></code> file and
compares results with the expectations.
Skeleton programs are very useful for a number of reasons:</p>
<ul class="simple">
<li><p>They can check correctness of various re2c optimizations (the data is
generated early in the process, before any DFA transformations have taken
place).</p></li>
<li><p>Generating a set of input data with good coverage may be useful for both
testing and benchmarking.</p></li>
<li><p>Generating self-contained executable programs allows one to get minimized test
cases (the original code may be large or have a lot of dependencies).</p></li>
</ul>
<p>The difficulty with generating input data is that for all but the most trivial
cases the number of possible input strings is too large (even if the string
length is limited). Re2c solves this difficulty by generating sufficiently
many strings to cover almost all DFA transitions. It uses the following
algorithm. First, it constructs a skeleton of the DFA. For encodings with 1-byte
code unit size (such as ASCII, UTF-8 and EBCDIC) skeleton is just an exact copy
of the original DFA. For encodings with multibyte code units skeleton is a copy
of DFA with certain transitions omitted: namely, re2c takes at most 256 code
units for each disjoint continuous range that corresponds to a DFA transition.
The chosen values are evenly distributed and include range bounds. Instead of
trying to cover all possible paths in the skeleton (which is infeasible) re2c
generates sufficiently many paths to cover all skeleton transitions, and thus
trigger the corresponding conditional jumps in the lexer.
The algorithm implementation is limited by ~1Gb of transitions and consumes
constant amount of memory (re2c writes data to file as soon as it is generated).</p>
<p>Here is an example of a very simple program
<a class="reference download internal" download="" href="../_downloads/4caed16257e51197e186587663701796/example.re.txt"><code class="xref download docutils literal notranslate"><span class="pre">[example.re]</span></code></a>
that tries to match two-digit hexadecimal numbers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!re2c</span>
<span class="cm">    *              {}</span>
<span class="cm">    [0-9a-fA-F]{2} {}</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>We can see the generated DFA using <code class="docutils literal notranslate"><span class="pre">`re2c</span> <span class="pre">-D</span> <span class="pre">example.re</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">-Grankdir=LR</span> <span class="pre">-Tpng</span> <span class="pre">-o</span> <span class="pre">example.png`</span></code>:</p>
<a class="reference internal image-reference" href="../_images/example.png"><img alt="../_images/example.png" src="../_images/example.png" style="width: 60%;" /></a>
<p>Given this program, <code class="docutils literal notranslate"><span class="pre">`re2c</span> <span class="pre">-S</span> <span class="pre">-o</span> <span class="pre">example.c</span> <span class="pre">example.re`</span></code> generates three files:
<code class="docutils literal notranslate"><span class="pre">example.c</span></code> (main program), <code class="docutils literal notranslate"><span class="pre">example.c.line4.input</span></code> (input data) and <code class="docutils literal notranslate"><span class="pre">example.c.line4.keys</span></code> (expected match results).
First, letâs look at the generated strings
<a class="reference download internal" download="" href="../_downloads/bf4c0e8384551fa545a4cbd6b5da9833/example.c.line4.input"><code class="xref download docutils literal notranslate"><span class="pre">[example.c.line4.input]</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ hexdump -v -e &#39;&quot;%08_ax &quot; 24/1 &quot;%02x &quot;&#39; -e &#39;&quot; |&quot; 24/1 &quot;%_p&quot; &quot;|\n&quot;&#39; example.c.line4.input
00000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 |........................|
00000018 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f |........ !&quot;#$%&amp;&#39;()*+,-./|
00000030 3a 3b 3c 3d 3e 3f 40 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 |:;&lt;=&gt;?@GHIJKLMNOPQRSTUVW|
[ ... ]
</pre></div>
</div>
<p>Byte sequences correspond to the paths in DFA.
All strings are glued together, so itâs hard to tell where is the end of one string and the beginning of another.
For that re2c generates keys <a class="reference download internal" download="" href="../_downloads/3bd3f1e0652949352ce6f3c3a0bc3050/example.c.line4.keys"><code class="xref download docutils literal notranslate"><span class="pre">[example.c.line4.keys]</span></code></a>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$hexdump -v -e &#39;&quot;%08_ax &quot; 36/1 &quot;%02x &quot; &quot;\n&quot;&#39; example.c.line4.keys
00000000 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
00000024 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
00000048 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe 01 01 fe
[ ... ]
</pre></div>
</div>
<p>A key is a triplet: string length, the length of matching prefix and the number of matching rule.
(If tags are used, there is an additional key per each tag variable).
Keys are packed into an array.
In our case each key fits into 1 byte, but in case of a larger DFA they might take 2 or 4 bytes.
The generated program <a class="reference download internal" download="" href="../_downloads/ea4226ea3ffc27e5f3a1b980f37ec252/example.c.txt"><code class="xref download docutils literal notranslate"><span class="pre">[example.c]</span></code></a>
contains two auxilary functions: <code class="docutils literal notranslate"><span class="pre">read_file</span></code> and <code class="docutils literal notranslate"><span class="pre">action_line4</span></code>.
<code class="docutils literal notranslate"><span class="pre">read_file</span></code> is used to map <code class="docutils literal notranslate"><span class="pre">.input</span></code> and <code class="docutils literal notranslate"><span class="pre">.keys</span></code> files into memory (this function is shared between all lexers).
<code class="docutils literal notranslate"><span class="pre">action_line4</span></code> is a replacement for actions: it compares actual lexing results with the expected results.
This function is specific to each lexer.
Lexing is done by <code class="docutils literal notranslate"><span class="pre">lex_line4</span></code>: this function contains the generated DFA.
The skeleton program is self-contained, so we can compile and run it:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cc -o example example.c
$ ./example
$ echo $?
0
</pre></div>
</div>
<p>When everything is fine (there are no errors) the program outputs nothing and
exits with zero. For the sake of example, letâs pretend that re2c has an error
that results in a missing <code class="docutils literal notranslate"><span class="pre">case</span></code> statement:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ re2c -S -o example.c example.re
$ sed -i -e <span class="s2">&quot;s/case &#39;7&#39;://&quot;</span> example.c
$ cc -o example example.c
$ ./example
error: lex_line4: at position <span class="m">248</span> <span class="o">(</span>iteration <span class="m">241</span><span class="o">)</span>:
        expected: match length <span class="m">2</span>, rule <span class="m">0</span>
        actual:   match length <span class="m">1</span>, rule <span class="m">254</span>
</pre></div>
</div>
<p>Viola! Now the lexer complains about discrepancy between expected and actual
match results.</p>
<p>One special case of failure detected by skeleton programs is undefined control
flow in the lexer. Use <code class="docutils literal notranslate"><span class="pre">-Wundefined-control-flow</span></code> warning to catch all such
cases in in your code (more details <a class="reference external" href="/manual/manual.html#wundefined-control-flow">here</a>).</p>
</div>
<div class="section" id="visualization-and-debug">
<h2>Visualization and debug<a class="headerlink" href="#visualization-and-debug" title="Permalink to this headline">Â¶</a></h2>
<p>With the <code class="docutils literal notranslate"><span class="pre">-D,</span> <span class="pre">--emit-dot</span></code> option, re2c does not generate code. Instead,
it dumps the generated DFA in DOT format.
One can convert this dump to an image of the DFA using Graphviz or another library.
Note that this option shows the final DFA after it has gone through a number of
optimizations and transformations. Earlier stages can be dumped with various debug
options, such as <code class="docutils literal notranslate"><span class="pre">--dump-nfa</span></code>, <code class="docutils literal notranslate"><span class="pre">--dump-dfa-raw</span></code> etc. (see the full list of options).</p>
<p>Below is an example of generating a picture of DFA that accepts any UTF-8 code point
(<code class="docutils literal notranslate"><span class="pre">utf8_any.re</span></code>):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*!re2c</span>
<span class="cm">    *   {}</span>
<span class="cm">    [^] {}</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>Generate and render:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ re2c -D -8 utf8_any.re | dot -Tpng -o utf8_any.png
</pre></div>
</div>
<p>Here is the picture:</p>
<a class="reference internal image-reference" href="../_images/utf8_any.png"><img alt="../_images/utf8_any.png" src="../_images/utf8_any.png" style="width: 90%;" /></a>
</div>
<div class="section" id="more-examples">
<h2>More examples<a class="headerlink" href="#more-examples" title="Permalink to this headline">Â¶</a></h2>
<p>The following examples are for the C backend:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/real_world/example_cxx98.html">C++98 lexer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/submatch/example_parse_etc_passwd.html">Parsing /etc/passwd (with tags)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/submatch/example_parse_options.html">Parsing options (with tags)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/submatch/example_parse_records.html">Parsing records (with tags)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/submatch/example_uri_rfc3986.html">Parsing URI RFC-3986 (with tags)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/submatch/example_http_rfc7230.html">Parsing HTTP message headers RFC-7230 (with tags)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/reuse/example_braille.html">Parsing Braille patterns (with multiple encodings)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/c/generic_api/example_ifstream.html">Reading from std::ifstream (with generic API)</a></li>
</ul>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on May 21, 2021.
    </div>
  </body>
</html>